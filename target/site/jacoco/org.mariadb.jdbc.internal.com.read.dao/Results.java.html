<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="tr"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Results.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">mariadb-java-client</a> &gt; <a href="index.source.html" class="el_package">org.mariadb.jdbc.internal.com.read.dao</a> &gt; <span class="el_source">Results.java</span></div><h1>Results.java</h1><pre class="source lang-java linenums">/*
 *
 * MariaDB Client for Java
 *
 * Copyright (c) 2012-2014 Monty Program Ab.
 * Copyright (c) 2015-2017 MariaDB Ab.
 *
 * This library is free software; you can redistribute it and/or modify it under
 * the terms of the GNU Lesser General Public License as published by the Free
 * Software Foundation; either version 2.1 of the License, or (at your option)
 * any later version.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
 * for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License along
 * with this library; if not, write to Monty Program Ab info@montyprogram.com.
 *
 * This particular MariaDB Client for Java file is work
 * derived from a Drizzle-JDBC. Drizzle-JDBC file which is covered by subject to
 * the following copyright and notice provisions:
 *
 * Copyright (c) 2009-2011, Marcus Eriksson
 *
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 * Redistributions of source code must retain the above copyright notice, this list
 * of conditions and the following disclaimer.
 *
 * Redistributions in binary form must reproduce the above copyright notice, this
 * list of conditions and the following disclaimer in the documentation and/or
 * other materials provided with the distribution.
 *
 * Neither the name of the driver nor the names of its contributors may not be
 * used to endorse or promote products derived from this software without specific
 * prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS  AND CONTRIBUTORS &quot;AS IS&quot;
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
 * OF SUCH DAMAGE.
 *
 */

package org.mariadb.jdbc.internal.com.read.dao;

import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.ArrayDeque;
import java.util.Deque;
import org.mariadb.jdbc.MariaDbStatement;
import org.mariadb.jdbc.internal.com.read.resultset.SelectResultSet;
import org.mariadb.jdbc.internal.protocol.Protocol;
import org.mariadb.jdbc.internal.util.exceptions.ExceptionMapper;


public class Results {

  private MariaDbStatement statement;
  private int fetchSize;
  private boolean batch;
  private int expectedSize;
  private CmdInformation cmdInformation;
  private Deque&lt;SelectResultSet&gt; executionResults;
  private SelectResultSet resultSet;
  private SelectResultSet callableResultSet;
  private boolean binaryFormat;
  private int resultSetScrollType;
  private int resultSetConcurrency;
  private int autoGeneratedKeys;
  private int maxFieldSize;
  private int autoIncrement;
  private boolean rewritten;

  /**
   * Single Text query.
   * /! use internally, because autoincrement value is not right for multi-queries !/
   */
<span class="nc" id="L88">  public Results() {</span>
<span class="nc" id="L89">    this.statement = null;</span>
<span class="nc" id="L90">    this.fetchSize = 0;</span>
<span class="nc" id="L91">    this.maxFieldSize = 0;</span>
<span class="nc" id="L92">    this.batch = false;</span>
<span class="nc" id="L93">    this.expectedSize = 1;</span>
<span class="nc" id="L94">    this.cmdInformation = null;</span>
<span class="nc" id="L95">    this.binaryFormat = false;</span>
<span class="nc" id="L96">    this.resultSetScrollType = ResultSet.TYPE_FORWARD_ONLY;</span>
<span class="nc" id="L97">    this.resultSetConcurrency = ResultSet.CONCUR_READ_ONLY;</span>
<span class="nc" id="L98">    this.autoIncrement = 1;</span>
<span class="nc" id="L99">    this.autoGeneratedKeys = Statement.NO_GENERATED_KEYS;</span>
<span class="nc" id="L100">  }</span>

  /**
   * Constructor for specific statement.
   *
   * @param statement            current Statement.
   * @param autoIncrement        connection auto-increment
   * @param resultSetScrollType  one of the following &lt;code&gt;ResultSet&lt;/code&gt; constants:
   *                             &lt;code&gt;ResultSet.TYPE_FORWARD_ONLY&lt;/code&gt;,
   *                             &lt;code&gt;ResultSet.TYPE_SCROLL_INSENSITIVE&lt;/code&gt;, or
   *                             &lt;code&gt;ResultSet.TYPE_SCROLL_SENSITIVE&lt;/code&gt;
   * @param resultSetConcurrency a concurrency type; one of &lt;code&gt;ResultSet.CONCUR_READ_ONLY&lt;/code&gt;
   *                             or
   *                             &lt;code&gt;ResultSet.CONCUR_UPDATABLE&lt;/code&gt;
   */
  public Results(MariaDbStatement statement, int autoIncrement, int resultSetScrollType,
<span class="nc" id="L116">      int resultSetConcurrency) {</span>
<span class="nc" id="L117">    this.statement = statement;</span>
<span class="nc" id="L118">    this.fetchSize = 0;</span>
<span class="nc" id="L119">    this.maxFieldSize = 0;</span>
<span class="nc" id="L120">    this.batch = false;</span>
<span class="nc" id="L121">    this.expectedSize = 1;</span>
<span class="nc" id="L122">    this.cmdInformation = null;</span>
<span class="nc" id="L123">    this.binaryFormat = false;</span>
<span class="nc" id="L124">    this.resultSetScrollType = resultSetScrollType;</span>
<span class="nc" id="L125">    this.resultSetConcurrency = resultSetConcurrency;</span>
<span class="nc" id="L126">    this.autoIncrement = autoIncrement;</span>
<span class="nc" id="L127">    this.autoGeneratedKeys = Statement.NO_GENERATED_KEYS;</span>
<span class="nc" id="L128">  }</span>

  /**
   * Default constructor.
   *
   * @param statement            current statement
   * @param fetchSize            fetch size
   * @param batch                select result possible
   * @param expectedSize         expected size
   * @param binaryFormat         use binary protocol
   * @param resultSetScrollType  one of the following &lt;code&gt;ResultSet&lt;/code&gt; constants:
   *                             &lt;code&gt;ResultSet.TYPE_FORWARD_ONLY&lt;/code&gt;,
   *                             &lt;code&gt;ResultSet.TYPE_SCROLL_INSENSITIVE&lt;/code&gt;, or
   *                             &lt;code&gt;ResultSet.TYPE_SCROLL_SENSITIVE&lt;/code&gt;
   * @param resultSetConcurrency a concurrency type; one of &lt;code&gt;ResultSet.CONCUR_READ_ONLY&lt;/code&gt;
   *                             or
   *                             &lt;code&gt;ResultSet.CONCUR_UPDATABLE&lt;/code&gt;
   * @param autoGeneratedKeys    a flag indicating whether auto-generated keys should be returned;
   *                             one of
   *                             &lt;code&gt;Statement.RETURN_GENERATED_KEYS&lt;/code&gt;
   *                             or &lt;code&gt;Statement.NO_GENERATED_KEYS&lt;/code&gt;
   * @param autoIncrement        Connection auto-increment value
   */
  public Results(MariaDbStatement statement, int fetchSize, boolean batch, int expectedSize,
      boolean binaryFormat, int resultSetScrollType,
<span class="nc" id="L153">      int resultSetConcurrency, int autoGeneratedKeys, int autoIncrement) {</span>
<span class="nc" id="L154">    this.statement = statement;</span>
<span class="nc" id="L155">    this.fetchSize = fetchSize;</span>
<span class="nc" id="L156">    this.batch = batch;</span>
<span class="nc" id="L157">    this.maxFieldSize = statement.getMaxFieldSize();</span>
<span class="nc" id="L158">    this.expectedSize = expectedSize;</span>
<span class="nc" id="L159">    this.cmdInformation = null;</span>
<span class="nc" id="L160">    this.binaryFormat = binaryFormat;</span>
<span class="nc" id="L161">    this.resultSetScrollType = resultSetScrollType;</span>
<span class="nc" id="L162">    this.resultSetConcurrency = resultSetConcurrency;</span>
<span class="nc" id="L163">    this.autoIncrement = autoIncrement;</span>
<span class="nc" id="L164">    this.autoGeneratedKeys = autoGeneratedKeys;</span>
<span class="nc" id="L165">  }</span>

  /**
   * Add execution statistics.
   *
   * @param updateCount         number of updated rows
   * @param insertId            primary key
   * @param moreResultAvailable is there additional packet
   */
  public void addStats(long updateCount, long insertId, boolean moreResultAvailable) {
<span class="nc bnc" id="L175" title="All 2 branches missed.">    if (cmdInformation == null) {</span>
<span class="nc bnc" id="L176" title="All 2 branches missed.">      if (batch) {</span>
<span class="nc" id="L177">        cmdInformation = new CmdInformationBatch(expectedSize, autoIncrement);</span>
<span class="nc bnc" id="L178" title="All 2 branches missed.">      } else if (moreResultAvailable) {</span>
<span class="nc" id="L179">        cmdInformation = new CmdInformationMultiple(expectedSize, autoIncrement);</span>
      } else {
<span class="nc" id="L181">        cmdInformation = new CmdInformationSingle(insertId, updateCount, autoIncrement);</span>
<span class="nc" id="L182">        return;</span>
      }
    }
<span class="nc" id="L185">    cmdInformation.addSuccessStat(updateCount, insertId);</span>
<span class="nc" id="L186">  }</span>

  /**
   * Indicate that result is an Error, to set appropriate results.
   *
   * @param moreResultAvailable indicate if other results (ResultSet or updateCount) are available.
   */
  public void addStatsError(boolean moreResultAvailable) {
<span class="nc bnc" id="L194" title="All 2 branches missed.">    if (cmdInformation == null) {</span>
<span class="nc bnc" id="L195" title="All 2 branches missed.">      if (batch) {</span>
<span class="nc" id="L196">        cmdInformation = new CmdInformationBatch(expectedSize, autoIncrement);</span>
<span class="nc bnc" id="L197" title="All 2 branches missed.">      } else if (moreResultAvailable) {</span>
<span class="nc" id="L198">        cmdInformation = new CmdInformationMultiple(expectedSize, autoIncrement);</span>
      } else {
<span class="nc" id="L200">        cmdInformation = new CmdInformationSingle(0, Statement.EXECUTE_FAILED, autoIncrement);</span>
<span class="nc" id="L201">        return;</span>
      }
    }
<span class="nc" id="L204">    cmdInformation.addErrorStat();</span>
<span class="nc" id="L205">  }</span>

  public int getCurrentStatNumber() {
<span class="nc bnc" id="L208" title="All 2 branches missed.">    return (cmdInformation == null) ? 0 : cmdInformation.getCurrentStatNumber();</span>
  }

  /**
   * Add resultSet to results.
   *
   * @param resultSet           new resultSet.
   * @param moreResultAvailable indicate if other results (ResultSet or updateCount) are available.
   */
  public void addResultSet(SelectResultSet resultSet, boolean moreResultAvailable) {
<span class="nc bnc" id="L218" title="All 2 branches missed.">    if (resultSet.isCallableResult()) {</span>
<span class="nc" id="L219">      callableResultSet = resultSet;</span>
<span class="nc" id="L220">      return;</span>
    }
<span class="nc bnc" id="L222" title="All 2 branches missed.">    if (executionResults == null) {</span>
<span class="nc" id="L223">      executionResults = new ArrayDeque&lt;&gt;();</span>
    }
<span class="nc" id="L225">    executionResults.add(resultSet);</span>
<span class="nc bnc" id="L226" title="All 2 branches missed.">    if (cmdInformation == null) {</span>
<span class="nc bnc" id="L227" title="All 2 branches missed.">      if (batch) {</span>
<span class="nc" id="L228">        cmdInformation = new CmdInformationBatch(expectedSize, autoIncrement);</span>
<span class="nc bnc" id="L229" title="All 2 branches missed.">      } else if (moreResultAvailable) {</span>
<span class="nc" id="L230">        cmdInformation = new CmdInformationMultiple(expectedSize, autoIncrement);</span>
      } else {
<span class="nc" id="L232">        cmdInformation = new CmdInformationSingle(0, -1, autoIncrement);</span>
<span class="nc" id="L233">        return;</span>
      }
    }
<span class="nc" id="L236">    cmdInformation.addResultSetStat();</span>
<span class="nc" id="L237">  }</span>

  public CmdInformation getCmdInformation() {
<span class="nc" id="L240">    return cmdInformation;</span>
  }

  protected void setCmdInformation(CmdInformation cmdInformation) {
<span class="nc" id="L244">    this.cmdInformation = cmdInformation;</span>
<span class="nc" id="L245">  }</span>

  /**
   * Indicate that command / batch is finished, so set current resultSet if needed.
   * @return true id has cmdInformation
   */
  public boolean commandEnd() {
<span class="nc bnc" id="L252" title="All 2 branches missed.">    if (cmdInformation != null) {</span>
<span class="nc bnc" id="L253" title="All 4 branches missed.">      if (executionResults != null &amp;&amp; !cmdInformation.isCurrentUpdateCount()) {</span>
<span class="nc" id="L254">        resultSet = executionResults.poll();</span>
      } else {
<span class="nc" id="L256">        resultSet = null;</span>
      }
<span class="nc" id="L258">      cmdInformation.setRewrite(rewritten);</span>
    } else {
<span class="nc" id="L260">      resultSet = null;</span>
    }
<span class="nc bnc" id="L262" title="All 2 branches missed.">    return cmdInformation != null;</span>
  }

  public SelectResultSet getResultSet() {
<span class="nc" id="L266">    return resultSet;</span>
  }

  public SelectResultSet getCallableResultSet() {
<span class="nc" id="L270">    return callableResultSet;</span>
  }

  /**
   * &lt;p&gt;Load fully current results.&lt;/p&gt;
   * &lt;p&gt;&lt;i&gt;Lock must be set before using this method&lt;/i&gt;&lt;/p&gt;
   *
   * @param skip     must result be available afterwhile
   * @param protocol current protocol
   * @throws SQLException if any connection error occur
   */
  public void loadFully(boolean skip, Protocol protocol) throws SQLException {
<span class="nc bnc" id="L282" title="All 2 branches missed.">    if (fetchSize != 0) {</span>
<span class="nc" id="L283">      fetchSize = 0;</span>
<span class="nc bnc" id="L284" title="All 2 branches missed.">      if (resultSet != null) {</span>
<span class="nc bnc" id="L285" title="All 2 branches missed.">        if (skip) {</span>
<span class="nc" id="L286">          resultSet.close();</span>
        } else {
<span class="nc" id="L288">          resultSet.fetchRemaining();</span>
        }
      } else {
<span class="nc" id="L291">        SelectResultSet firstResult = executionResults.peekFirst();</span>
<span class="nc bnc" id="L292" title="All 2 branches missed.">        if (firstResult != null) {</span>
<span class="nc bnc" id="L293" title="All 2 branches missed.">          if (skip) {</span>
<span class="nc" id="L294">            firstResult.close();</span>
          } else {
<span class="nc" id="L296">            firstResult.fetchRemaining();</span>
          }
        }
      }
    }

<span class="nc bnc" id="L302" title="All 2 branches missed.">    if (protocol.hasMoreResults()) {</span>
<span class="nc" id="L303">      protocol.getResult(this);</span>
    }
<span class="nc" id="L305">  }</span>

  /**
   * Connection.abort() has been called, abort remaining active result-set
   *
   * @throws SQLException exception
   */
  public void abort() throws SQLException {
<span class="nc bnc" id="L313" title="All 2 branches missed.">    if (fetchSize != 0) {</span>
<span class="nc" id="L314">      fetchSize = 0;</span>
<span class="nc bnc" id="L315" title="All 2 branches missed.">      if (resultSet != null) {</span>
<span class="nc" id="L316">        resultSet.abort();</span>
      } else {
<span class="nc" id="L318">        SelectResultSet firstResult = executionResults.peekFirst();</span>
<span class="nc bnc" id="L319" title="All 2 branches missed.">        if (firstResult != null) {</span>
<span class="nc" id="L320">          firstResult.abort();</span>
        }
      }
    }
<span class="nc" id="L324">  }</span>

  /**
   * Indicate if result contain result-set that is still streaming from server.
   *
   * @param protocol current protocol
   * @return true if streaming is finished
   */
  public boolean isFullyLoaded(Protocol protocol) {
<span class="nc bnc" id="L333" title="All 4 branches missed.">    if (fetchSize == 0 || resultSet == null) {</span>
<span class="nc" id="L334">      return true;</span>
    }
<span class="nc bnc" id="L336" title="All 2 branches missed.">    return resultSet.isFullyLoaded()</span>
<span class="nc bnc" id="L337" title="All 2 branches missed.">            &amp;&amp; executionResults.isEmpty()</span>
<span class="nc bnc" id="L338" title="All 2 branches missed.">            &amp;&amp; !protocol.hasMoreResults();</span>
  }

  /**
   * Position to next resultSet.
   *
   * @param current  one of the following &lt;code&gt;Statement&lt;/code&gt; constants indicating what should
   *                 happen to current
   *                 &lt;code&gt;ResultSet&lt;/code&gt; objects obtained using the method
   *                 &lt;code&gt;getResultSet&lt;/code&gt;:
   *                 &lt;code&gt;Statement.CLOSE_CURRENT_RESULT&lt;/code&gt;, &lt;code&gt;Statement.KEEP_CURRENT_RESULT&lt;/code&gt;,
   *                 or &lt;code&gt;Statement.CLOSE_ALL_RESULTS&lt;/code&gt;
   * @param protocol current protocol
   * @return true if other resultSet exists.
   * @throws SQLException if any connection error occur.
   */
  public boolean getMoreResults(final int current, Protocol protocol) throws SQLException {
<span class="nc bnc" id="L355" title="All 4 branches missed.">    if (fetchSize != 0 &amp;&amp; resultSet != null) {</span>

<span class="nc" id="L357">      protocol.getLock().lock();</span>
      try {
        //load current resultSet
<span class="nc bnc" id="L360" title="All 4 branches missed.">        if (current == Statement.CLOSE_CURRENT_RESULT &amp;&amp; resultSet != null) {</span>
<span class="nc" id="L361">          resultSet.close();</span>
        } else {
<span class="nc" id="L363">          resultSet.fetchRemaining();</span>
        }

        //load next data if there is
<span class="nc bnc" id="L367" title="All 2 branches missed.">        if (protocol.hasMoreResults()) {</span>
<span class="nc" id="L368">          protocol.getResult(this);</span>
        }

<span class="nc" id="L371">      } catch (SQLException e) {</span>
<span class="nc" id="L372">        ExceptionMapper.throwException(e, null, statement);</span>
      } finally {
<span class="nc" id="L374">        protocol.getLock().unlock();</span>
      }

    }

<span class="nc bnc" id="L379" title="All 4 branches missed.">    if (cmdInformation.moreResults() &amp;&amp; !batch) {</span>

<span class="nc bnc" id="L381" title="All 4 branches missed.">      if (current == Statement.CLOSE_CURRENT_RESULT &amp;&amp; resultSet != null) {</span>
<span class="nc" id="L382">        resultSet.close();</span>
      }
<span class="nc bnc" id="L384" title="All 2 branches missed.">      if (executionResults != null) {</span>
<span class="nc" id="L385">        resultSet = executionResults.poll();</span>
      }
<span class="nc bnc" id="L387" title="All 2 branches missed.">      return resultSet != null;</span>

    } else {

<span class="nc bnc" id="L391" title="All 4 branches missed.">      if (current == Statement.CLOSE_CURRENT_RESULT &amp;&amp; resultSet != null) {</span>
<span class="nc" id="L392">        resultSet.close();</span>
      }
<span class="nc" id="L394">      resultSet = null;</span>
<span class="nc" id="L395">      return false;</span>

    }

  }

  public int getFetchSize() {
<span class="nc" id="L402">    return fetchSize;</span>
  }

  public MariaDbStatement getStatement() {
<span class="nc" id="L406">    return statement;</span>
  }

  public boolean isBatch() {
<span class="nc" id="L410">    return batch;</span>
  }

  public int getExpectedSize() {
<span class="nc" id="L414">    return expectedSize;</span>
  }

  public boolean isBinaryFormat() {
<span class="nc" id="L418">    return binaryFormat;</span>
  }

  public void removeFetchSize() {
<span class="nc" id="L422">    fetchSize = 0;</span>
<span class="nc" id="L423">  }</span>

  public int getResultSetScrollType() {
<span class="nc" id="L426">    return resultSetScrollType;</span>
  }

  /**
   * Send a resultSet that contain auto generated keys. 2 differences :
   * &lt;ol&gt;
   * &lt;li&gt;Batch will list all insert ids.&lt;/li&gt;
   * &lt;li&gt;in case of multi-query is set, resultSet will be per query. &lt;/li&gt;
   * &lt;/ol&gt;
   *
   * &lt;p&gt;example &quot;INSERT INTO myTable values ('a'),('b');INSERT INTO myTable values ('c'),('d'),('e')&quot;
   * will have a resultSet of 2 values, and when Statement.getMoreResults() will be called, a
   * Statement.getGeneratedKeys will return a resultset with 3 ids.&lt;/p&gt;
   *
   * @param protocol current protocol
   * @return a ResultSet containing generated ids.
   * @throws SQLException if autoGeneratedKeys was not set to Statement.RETURN_GENERATED_KEYS
   */
  public ResultSet getGeneratedKeys(Protocol protocol) throws SQLException {
<span class="nc bnc" id="L445" title="All 2 branches missed.">    if (autoGeneratedKeys != Statement.RETURN_GENERATED_KEYS) {</span>
<span class="nc" id="L446">      throw new SQLException(</span>
          &quot;Cannot return generated keys : query was not set with Statement.RETURN_GENERATED_KEYS&quot;);
    }
<span class="nc bnc" id="L449" title="All 2 branches missed.">    if (cmdInformation != null) {</span>
<span class="nc bnc" id="L450" title="All 2 branches missed.">      if (batch) {</span>
<span class="nc" id="L451">        return cmdInformation.getBatchGeneratedKeys(protocol);</span>
      }
<span class="nc" id="L453">      return cmdInformation.getGeneratedKeys(protocol);</span>
    }
<span class="nc" id="L455">    return SelectResultSet.createEmptyResultSet();</span>
  }

  public void close() {
<span class="nc" id="L459">    statement = null;</span>
<span class="nc" id="L460">    fetchSize = 0;</span>
<span class="nc" id="L461">  }</span>

  public int getMaxFieldSize() {
<span class="nc" id="L464">    return maxFieldSize;</span>
  }

  public void setAutoIncrement(int autoIncrement) {
<span class="nc" id="L468">    this.autoIncrement = autoIncrement;</span>
<span class="nc" id="L469">  }</span>

  public int getResultSetConcurrency() {
<span class="nc" id="L472">    return resultSetConcurrency;</span>
  }

  public int getAutoGeneratedKeys() {
<span class="nc" id="L476">    return autoGeneratedKeys;</span>
  }

  public boolean isRewritten() {
<span class="nc" id="L480">    return rewritten;</span>
  }

  public void setRewritten(boolean rewritten) {
<span class="nc" id="L484">    this.rewritten = rewritten;</span>
<span class="nc" id="L485">  }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>