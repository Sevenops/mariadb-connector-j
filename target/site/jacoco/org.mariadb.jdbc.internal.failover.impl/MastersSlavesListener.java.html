<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="tr"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>MastersSlavesListener.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">mariadb-java-client</a> &gt; <a href="index.source.html" class="el_package">org.mariadb.jdbc.internal.failover.impl</a> &gt; <span class="el_source">MastersSlavesListener.java</span></div><h1>MastersSlavesListener.java</h1><pre class="source lang-java linenums">/*
 *
 * MariaDB Client for Java
 *
 * Copyright (c) 2012-2014 Monty Program Ab.
 * Copyright (c) 2015-2017 MariaDB Ab.
 *
 * This library is free software; you can redistribute it and/or modify it under
 * the terms of the GNU Lesser General Public License as published by the Free
 * Software Foundation; either version 2.1 of the License, or (at your option)
 * any later version.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
 * for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License along
 * with this library; if not, write to Monty Program Ab info@montyprogram.com.
 *
 * This particular MariaDB Client for Java file is work
 * derived from a Drizzle-JDBC. Drizzle-JDBC file which is covered by subject to
 * the following copyright and notice provisions:
 *
 * Copyright (c) 2009-2011, Marcus Eriksson
 *
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 * Redistributions of source code must retain the above copyright notice, this list
 * of conditions and the following disclaimer.
 *
 * Redistributions in binary form must reproduce the above copyright notice, this
 * list of conditions and the following disclaimer in the documentation and/or
 * other materials provided with the distribution.
 *
 * Neither the name of the driver nor the names of its contributors may not be
 * used to endorse or promote products derived from this software without specific
 * prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS  AND CONTRIBUTORS &quot;AS IS&quot;
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
 * OF SUCH DAMAGE.
 *
 */

package org.mariadb.jdbc.internal.failover.impl;

import static org.mariadb.jdbc.internal.util.SqlStates.CONNECTION_EXCEPTION;

import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.net.SocketException;
import java.sql.SQLException;
import java.sql.SQLNonTransientConnectionException;
import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Collections;
import java.util.LinkedList;
import java.util.List;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicInteger;
import org.mariadb.jdbc.HostAddress;
import org.mariadb.jdbc.MariaDbConnection;
import org.mariadb.jdbc.MariaDbStatement;
import org.mariadb.jdbc.UrlParser;
import org.mariadb.jdbc.internal.failover.AbstractMastersSlavesListener;
import org.mariadb.jdbc.internal.failover.HandleErrorResult;
import org.mariadb.jdbc.internal.failover.thread.FailoverLoop;
import org.mariadb.jdbc.internal.failover.tools.SearchFilter;
import org.mariadb.jdbc.internal.logging.Logger;
import org.mariadb.jdbc.internal.logging.LoggerFactory;
import org.mariadb.jdbc.internal.protocol.MastersSlavesProtocol;
import org.mariadb.jdbc.internal.protocol.Protocol;
import org.mariadb.jdbc.internal.util.dao.ReconnectDuringTransactionException;
import org.mariadb.jdbc.internal.util.dao.ServerPrepareResult;
import org.mariadb.jdbc.internal.util.pool.GlobalStateInfo;
import org.mariadb.jdbc.internal.util.scheduler.DynamicSizedSchedulerInterface;
import org.mariadb.jdbc.internal.util.scheduler.SchedulerServiceProviderHolder;


/**
 * this class handle the operation when multiple hosts.
 */
public class MastersSlavesListener extends AbstractMastersSlavesListener {

  private static final DynamicSizedSchedulerInterface dynamicSizedScheduler;
<span class="nc" id="L94">  private static final AtomicInteger listenerCount = new AtomicInteger();</span>
<span class="nc" id="L95">  private static final Logger logger = LoggerFactory.getLogger(MastersSlavesListener.class);</span>

  static {
<span class="nc" id="L98">    dynamicSizedScheduler = SchedulerServiceProviderHolder.getScheduler(1, &quot;MariaDb-failover&quot;, 8);</span>

    // fail loop scaling happens async and only from a single thread
<span class="nc" id="L101">    dynamicSizedScheduler.scheduleWithFixedDelay(new Runnable() {</span>
<span class="nc" id="L102">      private final ArrayDeque&lt;FailoverLoop&gt; failoverLoops = new ArrayDeque&lt;&gt;(8);</span>

      @Override
      public void run() {

<span class="nc" id="L107">        int desiredFailCount = Math.min(8, listenerCount.get() / 5 + 1);</span>
<span class="nc" id="L108">        int countChange = desiredFailCount - failoverLoops.size();</span>

<span class="nc bnc" id="L110" title="All 2 branches missed.">        if (countChange != 0) {</span>
<span class="nc" id="L111">          dynamicSizedScheduler.setPoolSize(desiredFailCount);</span>
<span class="nc bnc" id="L112" title="All 2 branches missed.">          if (countChange &gt; 0) {</span>
            // start fail loops
<span class="nc bnc" id="L114" title="All 2 branches missed.">            for (; countChange &gt; 0; countChange--) {</span>
              // loop is started in constructor
<span class="nc" id="L116">              failoverLoops.add(new FailoverLoop(dynamicSizedScheduler));</span>
            }
          } else {
            // block on all removed loops after finished unscheduling to reduce blocking
<span class="nc" id="L120">            List&lt;FailoverLoop&gt; removedLoops = new ArrayList&lt;&gt;(-countChange);</span>
            // terminate fail loops
<span class="nc bnc" id="L122" title="All 2 branches missed.">            for (; countChange &lt; 0; countChange++) {</span>
<span class="nc" id="L123">              FailoverLoop failoverLoop = failoverLoops.remove();</span>
<span class="nc" id="L124">              failoverLoop.unscheduleTask();</span>
<span class="nc" id="L125">              removedLoops.add(failoverLoop);</span>
            }

<span class="nc bnc" id="L128" title="All 2 branches missed.">            for (FailoverLoop failoverLoop : removedLoops) {</span>
<span class="nc" id="L129">              failoverLoop.blockTillTerminated();</span>
<span class="nc" id="L130">            }</span>
          }
        }
<span class="nc" id="L133">      }</span>
    }, 1, 2, TimeUnit.MINUTES);
<span class="nc" id="L135">  }</span>

  protected Protocol masterProtocol;
  protected Protocol secondaryProtocol;

  /**
   * Initialisation.
   *
   * @param urlParser  connection string object.
   * @param globalInfo server global variables information
   */
  public MastersSlavesListener(final UrlParser urlParser, final GlobalStateInfo globalInfo) {
<span class="nc" id="L147">    super(urlParser, globalInfo);</span>
<span class="nc" id="L148">    listenerCount.incrementAndGet();</span>
<span class="nc" id="L149">    masterProtocol = null;</span>
<span class="nc" id="L150">    secondaryProtocol = null;</span>
<span class="nc" id="L151">    setMasterHostFail();</span>
<span class="nc" id="L152">    setSecondaryHostFail();</span>
<span class="nc" id="L153">  }</span>

  protected void removeListenerFromSchedulers() {
<span class="nc" id="L156">    super.removeListenerFromSchedulers();</span>
<span class="nc" id="L157">    FailoverLoop.removeListener(this);</span>
<span class="nc" id="L158">    listenerCount.addAndGet(-1);</span>
<span class="nc" id="L159">  }</span>

  /**
   * Initialize connections.
   *
   * @throws SQLException if a connection error append.
   */
  @Override
  public void initializeConnection() throws SQLException {
<span class="nc" id="L168">    super.initializeConnection();</span>
    try {
<span class="nc" id="L170">      reconnectFailedConnection(new SearchFilter(true));</span>
<span class="nc" id="L171">    } catch (SQLException e) {</span>
      //initializeConnection failed
<span class="nc" id="L173">      checkInitialConnection(e);</span>
<span class="nc" id="L174">    }</span>
<span class="nc" id="L175">  }</span>

  @Override
  public boolean isClosed() {
<span class="nc bnc" id="L179" title="All 2 branches missed.">    if (currentProtocol != null) {</span>
<span class="nc" id="L180">      return currentProtocol.isClosed();</span>
    }
<span class="nc bnc" id="L182" title="All 2 branches missed.">    if (urlParser.getOptions().allowMasterDownConnection) {</span>
<span class="nc" id="L183">      return secondaryProtocol.isClosed();</span>
    }
<span class="nc" id="L185">    return false;</span>
  }

  @Override
  public Object invoke(Method method, Object[] args) throws Throwable {
<span class="nc bnc" id="L190" title="All 2 branches missed.">    if (currentProtocol == null) {</span>
      //possible with option &quot;allowMasterDownConnection&quot; set and no master found.
      //must try to reconnect
      try {
<span class="nc" id="L194">        reconnectFailedConnection(new SearchFilter(true, false));</span>
<span class="nc" id="L195">        handleFailLoop();</span>

<span class="nc" id="L197">      } catch (SQLException e) {</span>
        //stop failover, since we will throw a connection exception that will close the connection.
<span class="nc" id="L199">        FailoverLoop.removeListener(this);</span>
<span class="nc" id="L200">        throw new InvocationTargetException(</span>
            new SQLNonTransientConnectionException(
                &quot;No master connection available (only read-only)\n&quot;
                    + &quot;(Possible because option allowMasterDownConnection is set)&quot;,
<span class="nc" id="L204">                CONNECTION_EXCEPTION.getSqlState()));</span>
<span class="nc" id="L205">      }</span>

<span class="nc bnc" id="L207" title="All 2 branches missed.">      if (!isMasterHostFail()) {</span>
        //connection established, no need to send Exception !
        //switching to master connection
        try {
<span class="nc" id="L211">          syncConnection(this.secondaryProtocol, this.masterProtocol);</span>
<span class="nc" id="L212">          currentProtocol = this.masterProtocol;</span>
<span class="nc" id="L213">          return method.invoke(currentProtocol, args);</span>
<span class="nc" id="L214">        } catch (SQLException e) {</span>
          //switching to master connection failed
<span class="nc bnc" id="L216" title="All 2 branches missed.">          if (setMasterHostFail()) {</span>
<span class="nc" id="L217">            addToBlacklist(masterProtocol.getHostAddress());</span>
          }
        }
      }
<span class="nc" id="L221">      throw new InvocationTargetException(</span>
          new SQLNonTransientConnectionException(&quot;No master connection available (only read-only)\n&quot;
              + &quot;(Possible because option allowMasterDownConnection is set)&quot;,
<span class="nc" id="L224">              CONNECTION_EXCEPTION.getSqlState()));</span>
    }
<span class="nc" id="L226">    return method.invoke(currentProtocol, args);</span>
  }

  @Override
  public boolean versionGreaterOrEqual(int major, int minor, int patch) {
<span class="nc bnc" id="L231" title="All 2 branches missed.">    Protocol protocol = (currentProtocol != null) ? currentProtocol : secondaryProtocol;</span>
<span class="nc bnc" id="L232" title="All 2 branches missed.">    if (protocol == null) {</span>
<span class="nc" id="L233">      return false;</span>
    }
<span class="nc" id="L235">    return protocol.versionGreaterOrEqual(major, minor, patch);</span>
  }

  @Override
  public boolean sessionStateAware() {
<span class="nc bnc" id="L240" title="All 2 branches missed.">    Protocol protocol = (currentProtocol != null) ? currentProtocol : secondaryProtocol;</span>
<span class="nc bnc" id="L241" title="All 2 branches missed.">    if (protocol == null) {</span>
<span class="nc" id="L242">      return false;</span>
    }
<span class="nc" id="L244">    return protocol.sessionStateAware();</span>
  }

  @Override
  public String getCatalog() throws SQLException {
<span class="nc bnc" id="L249" title="All 2 branches missed.">    Protocol protocol = (currentProtocol != null) ? currentProtocol : secondaryProtocol;</span>
<span class="nc bnc" id="L250" title="All 2 branches missed.">    if (protocol == null) {</span>
<span class="nc" id="L251">      return urlParser.getDatabase();</span>
    }
<span class="nc" id="L253">    return protocol.getCatalog();</span>
  }

  @Override
  public int getMajorServerVersion() {
<span class="nc bnc" id="L258" title="All 2 branches missed.">    Protocol protocol = (currentProtocol != null) ? currentProtocol : secondaryProtocol;</span>
<span class="nc bnc" id="L259" title="All 2 branches missed.">    if (protocol == null) {</span>
<span class="nc" id="L260">      return 5;</span>
    }
<span class="nc" id="L262">    return protocol.getMajorServerVersion();</span>
  }

  public boolean isMasterConnection() {
<span class="nc bnc" id="L266" title="All 4 branches missed.">    return (currentProtocol == null) || currentProtocol.isMasterConnection();</span>
  }

  /**
   * Get timeout (master connection possibly down).
   *
   * @return socket timeout in ms
   * @throws SocketException if socket exception
   */
  public int getTimeout() throws SocketException {
<span class="nc bnc" id="L276" title="All 2 branches missed.">    if (currentProtocol != null) {</span>
<span class="nc" id="L277">      return currentProtocol.getTimeout();</span>
    }
<span class="nc bnc" id="L279" title="All 2 branches missed.">    return ((urlParser.getOptions().socketTimeout == null) ? 0</span>
<span class="nc" id="L280">        : urlParser.getOptions().socketTimeout);</span>
  }

  @Override
  public void prolog(long maxRows, MariaDbConnection connection, MariaDbStatement statement)
      throws SQLException {
<span class="nc bnc" id="L286" title="All 2 branches missed.">    if (currentProtocol != null) {</span>
<span class="nc" id="L287">      currentProtocol.prolog(maxRows, true, connection, statement);</span>
    }
<span class="nc" id="L289">  }</span>

  @Override
  public boolean noBackslashEscapes() {
<span class="nc bnc" id="L293" title="All 2 branches missed.">    Protocol protocol = (currentProtocol != null) ? currentProtocol : secondaryProtocol;</span>
<span class="nc" id="L294">    return protocol.noBackslashEscapes();</span>
  }

  /**
   * Get current connection server id.
   *
   * @return server id.
   */
  public long getServerThreadId() {
<span class="nc bnc" id="L303" title="All 2 branches missed.">    if (currentProtocol == null) {</span>
<span class="nc" id="L304">      return -1L;</span>
    }
<span class="nc" id="L306">    return currentProtocol.getServerThreadId();</span>
  }

  protected void checkInitialConnection(SQLException queryException) throws SQLException {
    Protocol waitingProtocol;
<span class="nc bnc" id="L311" title="All 2 branches missed.">    if (isSecondaryHostFail()) {</span>
<span class="nc bnc" id="L312" title="All 2 branches missed.">      if ((waitingProtocol = waitNewSecondaryProtocol.getAndSet(null)) != null) {</span>
<span class="nc" id="L313">        this.secondaryProtocol = waitingProtocol;</span>
<span class="nc bnc" id="L314" title="All 2 branches missed.">        if (urlParser.getOptions().assureReadOnly) {</span>
<span class="nc" id="L315">          setSessionReadOnly(true, this.secondaryProtocol);</span>
        }
<span class="nc bnc" id="L317" title="All 2 branches missed.">        if (currentReadOnlyAsked) {</span>
<span class="nc" id="L318">          currentProtocol = waitingProtocol;</span>
        }
<span class="nc" id="L320">        resetSecondaryFailoverData();</span>
      }
    }
<span class="nc bnc" id="L323" title="All 2 branches missed.">    if (isMasterHostFail()) {</span>
<span class="nc bnc" id="L324" title="All 2 branches missed.">      if ((waitingProtocol = waitNewMasterProtocol.getAndSet(null)) != null) {</span>
<span class="nc" id="L325">        this.masterProtocol = waitingProtocol;</span>
<span class="nc bnc" id="L326" title="All 4 branches missed.">        if (!currentReadOnlyAsked || isSecondaryHostFail()) {</span>
<span class="nc" id="L327">          currentProtocol = waitingProtocol;</span>
        }
<span class="nc" id="L329">        resetMasterFailoverData();</span>
      }
    }

<span class="nc bnc" id="L333" title="All 4 branches missed.">    if (this.masterProtocol == null || !this.masterProtocol.isConnected()) {</span>
<span class="nc" id="L334">      setMasterHostFail();</span>
<span class="nc bnc" id="L335" title="All 4 branches missed.">      if (!(urlParser.getOptions().allowMasterDownConnection &amp;&amp; secondaryProtocol != null)) {</span>
<span class="nc bnc" id="L336" title="All 2 branches missed.">        throwFailoverMessage(masterProtocol != null ? masterProtocol.getHostAddress() : null, true,</span>
            queryException, false);
      }
    } else {
<span class="nc" id="L340">      resetMasterFailoverData();</span>
<span class="nc bnc" id="L341" title="All 2 branches missed.">      if (isSecondaryHostFail()) {</span>
        //launched failLoop only if not throwing connection (connection will be closed).
<span class="nc" id="L343">        handleFailLoop();</span>
      }
    }
<span class="nc" id="L346">  }</span>

  /**
   * Called after a call on Connection.close(). Will explicitly closed all connections.
   */
  public void preClose() {
<span class="nc bnc" id="L352" title="All 2 branches missed.">    if (explicitClosed.compareAndSet(false, true)) {</span>
<span class="nc" id="L353">      proxy.lock.lock();</span>
      try {
<span class="nc" id="L355">        removeListenerFromSchedulers();</span>

        //closing connections
<span class="nc" id="L358">        closeConnection(waitNewSecondaryProtocol.getAndSet(null));</span>
<span class="nc" id="L359">        closeConnection(waitNewMasterProtocol.getAndSet(null));</span>
<span class="nc" id="L360">        closeConnection(masterProtocol);</span>
<span class="nc" id="L361">        closeConnection(secondaryProtocol);</span>
      } finally {
<span class="nc" id="L363">        proxy.lock.unlock();</span>
      }
    }
<span class="nc" id="L366">  }</span>

  @Override
  public void preAbort() {
<span class="nc bnc" id="L370" title="All 2 branches missed.">    if (explicitClosed.compareAndSet(false, true)) {</span>
<span class="nc" id="L371">      proxy.lock.lock();</span>
      try {
<span class="nc" id="L373">        removeListenerFromSchedulers();</span>

        //closing connections
<span class="nc" id="L376">        abortConnection(waitNewSecondaryProtocol.getAndSet(null));</span>
<span class="nc" id="L377">        abortConnection(waitNewMasterProtocol.getAndSet(null));</span>
<span class="nc" id="L378">        abortConnection(masterProtocol);</span>
<span class="nc" id="L379">        abortConnection(secondaryProtocol);</span>
      } finally {
<span class="nc" id="L381">        proxy.lock.unlock();</span>
      }
    }
<span class="nc" id="L384">  }</span>

  @Override
  public void preExecute() throws SQLException {
<span class="nc" id="L388">    lastQueryNanos = System.nanoTime();</span>
<span class="nc" id="L389">    checkWaitingConnection();</span>
    //if connection is closed or failed on slave
<span class="nc bnc" id="L391" title="All 2 branches missed.">    if (this.currentProtocol != null</span>
<span class="nc bnc" id="L392" title="All 4 branches missed.">        &amp;&amp; (this.currentProtocol.isClosed() || (!currentReadOnlyAsked &amp;&amp; !currentProtocol</span>
<span class="nc bnc" id="L393" title="All 2 branches missed.">        .isMasterConnection()))) {</span>
<span class="nc" id="L394">      preAutoReconnect();</span>
    }
<span class="nc" id="L396">  }</span>


  @Override
  public boolean isValid(int timeout) throws SQLException {
<span class="nc bnc" id="L401" title="All 2 branches missed.">    if (currentProtocol != null) {</span>
<span class="nc bnc" id="L402" title="All 2 branches missed.">      if (currentProtocol.isMasterConnection()) {</span>
<span class="nc" id="L403">        boolean valid = currentProtocol.isValid(timeout);</span>
<span class="nc bnc" id="L404" title="All 2 branches missed.">        if (secondaryProtocol != null) {</span>
          //ping secondary protocol too to avoid any server timeout
          try {
<span class="nc" id="L407">            boolean secondValid = secondaryProtocol.isValid(timeout);</span>
<span class="nc bnc" id="L408" title="All 6 branches missed.">            if (!valid &amp;&amp; urlParser.getOptions().allowMasterDownConnection &amp;&amp; secondValid) {</span>
<span class="nc" id="L409">              setMasterHostFail();</span>
<span class="nc" id="L410">              return true;</span>
            }
<span class="nc" id="L412">          } catch (SQLException sqle) {</span>
            //eat
<span class="nc" id="L414">          }</span>
        }
<span class="nc" id="L416">        return valid;</span>
      } else {
<span class="nc" id="L418">        boolean valid = currentProtocol.isValid(timeout);</span>
<span class="nc bnc" id="L419" title="All 2 branches missed.">        if (masterProtocol != null) {</span>
          //ping secondary protocol too to avoid any server timeout
          try {
<span class="nc" id="L422">            masterProtocol.isValid(timeout);</span>
<span class="nc" id="L423">          } catch (SQLException sqle) {</span>
            //eat
<span class="nc" id="L425">          }</span>
        }
<span class="nc" id="L427">        return valid;</span>
      }
    }
<span class="nc" id="L430">    return false;</span>
  }

  /**
   * Verify that there is waiting connection that have to replace failing one. If there is replace
   * failed connection with new one.
   *
   * @throws SQLException if error occur
   */
  public void checkWaitingConnection() throws SQLException {
<span class="nc bnc" id="L440" title="All 2 branches missed.">    if (isSecondaryHostFail()) {</span>
<span class="nc" id="L441">      proxy.lock.lock();</span>
      try {
<span class="nc" id="L443">        Protocol waitingProtocol = waitNewSecondaryProtocol.getAndSet(null);</span>
<span class="nc bnc" id="L444" title="All 4 branches missed.">        if (waitingProtocol != null &amp;&amp; pingSecondaryProtocol(waitingProtocol)) {</span>
<span class="nc" id="L445">          lockAndSwitchSecondary(waitingProtocol);</span>
        }
      } finally {
<span class="nc" id="L448">        proxy.lock.unlock();</span>
      }
    }

<span class="nc bnc" id="L452" title="All 2 branches missed.">    if (isMasterHostFail()) {</span>
<span class="nc" id="L453">      proxy.lock.lock();</span>
      try {
<span class="nc" id="L455">        Protocol waitingProtocol = waitNewMasterProtocol.getAndSet(null);</span>
<span class="nc bnc" id="L456" title="All 4 branches missed.">        if (waitingProtocol != null &amp;&amp; pingMasterProtocol(waitingProtocol)) {</span>
<span class="nc" id="L457">          lockAndSwitchMaster(waitingProtocol);</span>
        }
      } finally {
<span class="nc" id="L460">        proxy.lock.unlock();</span>
      }
    }
<span class="nc" id="L463">  }</span>


  /**
   * Loop to connect.
   *
   * @throws SQLException if there is any error during reconnection
   */
  public void reconnectFailedConnection(SearchFilter searchFilter) throws SQLException {
<span class="nc bnc" id="L472" title="All 2 branches missed.">    if (!searchFilter.isInitialConnection()</span>
<span class="nc bnc" id="L473" title="All 2 branches missed.">        &amp;&amp; (isExplicitClosed()</span>
<span class="nc bnc" id="L474" title="All 4 branches missed.">        || (searchFilter.isFineIfFoundOnlyMaster() &amp;&amp; !isMasterHostFail())</span>
<span class="nc bnc" id="L475" title="All 4 branches missed.">        || searchFilter.isFineIfFoundOnlySlave() &amp;&amp; !isSecondaryHostFail())) {</span>
<span class="nc" id="L476">      return;</span>
    }
    //check if a connection has been retrieved by failoverLoop during lock
<span class="nc bnc" id="L479" title="All 2 branches missed.">    if (!searchFilter.isFailoverLoop()) {</span>
      try {
<span class="nc" id="L481">        checkWaitingConnection();</span>
<span class="nc bnc" id="L482" title="All 4 branches missed.">        if ((searchFilter.isFineIfFoundOnlyMaster() &amp;&amp; !isMasterHostFail())</span>
<span class="nc bnc" id="L483" title="All 4 branches missed.">            || searchFilter.isFineIfFoundOnlySlave() &amp;&amp; !isSecondaryHostFail()) {</span>
<span class="nc" id="L484">          return;</span>
        }
<span class="nc" id="L486">      } catch (ReconnectDuringTransactionException e) {</span>
        //don't throw an exception for this specific exception
<span class="nc" id="L488">        return;</span>
<span class="nc" id="L489">      }</span>
    }

<span class="nc" id="L492">    currentConnectionAttempts.incrementAndGet();</span>
<span class="nc" id="L493">    resetOldsBlackListHosts();</span>

    //put the list in the following order
    // - random order not blacklist and not connected host
    // - random order blacklist host
    // - connected host
<span class="nc" id="L499">    List&lt;HostAddress&gt; loopAddress = new LinkedList&lt;&gt;(urlParser.getHostAddresses());</span>
<span class="nc" id="L500">    loopAddress.removeAll(getBlacklistKeys());</span>
<span class="nc" id="L501">    Collections.shuffle(loopAddress);</span>
<span class="nc" id="L502">    List&lt;HostAddress&gt; blacklistShuffle = new LinkedList&lt;&gt;(getBlacklistKeys());</span>
<span class="nc" id="L503">    blacklistShuffle.retainAll(urlParser.getHostAddresses());</span>
<span class="nc" id="L504">    Collections.shuffle(blacklistShuffle);</span>
<span class="nc" id="L505">    loopAddress.addAll(blacklistShuffle);</span>

    //put connected at end
<span class="nc bnc" id="L508" title="All 4 branches missed.">    if (masterProtocol != null &amp;&amp; !isMasterHostFail()) {</span>
<span class="nc" id="L509">      loopAddress.remove(masterProtocol.getHostAddress());</span>
<span class="nc" id="L510">      loopAddress.add(masterProtocol.getHostAddress());</span>
    }

<span class="nc bnc" id="L513" title="All 4 branches missed.">    if (secondaryProtocol != null &amp;&amp; !isSecondaryHostFail()) {</span>
<span class="nc" id="L514">      loopAddress.remove(secondaryProtocol.getHostAddress());</span>
<span class="nc" id="L515">      loopAddress.add(secondaryProtocol.getHostAddress());</span>
    }

<span class="nc bnc" id="L518" title="All 4 branches missed.">    if ((isMasterHostFail() || isSecondaryHostFail())</span>
<span class="nc bnc" id="L519" title="All 2 branches missed.">        || searchFilter.isInitialConnection()) {</span>
      //while permit to avoid case when succeeded creating a new Master connection
      //and ping master connection fail a few millissecond after,
      //resulting a masterConnection not initialized.
      do {
<span class="nc" id="L524">        MastersSlavesProtocol.loop(this, globalInfo, loopAddress, searchFilter);</span>
        //close loop if all connection are retrieved
<span class="nc bnc" id="L526" title="All 2 branches missed.">        if (!searchFilter.isFailoverLoop()) {</span>
          try {
<span class="nc" id="L528">            checkWaitingConnection();</span>
<span class="nc" id="L529">          } catch (ReconnectDuringTransactionException e) {</span>
            //don't throw an exception for this specific exception
<span class="nc" id="L531">          }</span>
        }
<span class="nc bnc" id="L533" title="All 4 branches missed.">      } while (searchFilter.isInitialConnection()</span>
<span class="nc bnc" id="L534" title="All 4 branches missed.">          &amp;&amp; !(masterProtocol != null || (urlParser.getOptions().allowMasterDownConnection</span>
          &amp;&amp; secondaryProtocol != null)));

<span class="nc bnc" id="L537" title="All 6 branches missed.">      if (searchFilter.isInitialConnection() &amp;&amp; masterProtocol == null &amp;&amp; currentReadOnlyAsked) {</span>
<span class="nc" id="L538">        currentProtocol = this.secondaryProtocol;</span>
<span class="nc" id="L539">        currentReadOnlyAsked = true;</span>
      }

    }

<span class="nc" id="L544">  }</span>

  /**
   * Method called when a new Master connection is found after a fallback.
   *
   * @param newMasterProtocol the new active connection
   */
  public void foundActiveMaster(Protocol newMasterProtocol) {
<span class="nc bnc" id="L552" title="All 2 branches missed.">    if (isMasterHostFail()) {</span>
<span class="nc bnc" id="L553" title="All 2 branches missed.">      if (isExplicitClosed()) {</span>
<span class="nc" id="L554">        newMasterProtocol.close();</span>
<span class="nc" id="L555">        return;</span>
      }
<span class="nc bnc" id="L557" title="All 2 branches missed.">      if (!waitNewMasterProtocol.compareAndSet(null, newMasterProtocol)) {</span>
<span class="nc" id="L558">        newMasterProtocol.close();</span>
      }
    } else {
<span class="nc" id="L561">      newMasterProtocol.close();</span>
    }

<span class="nc" id="L564">  }</span>

  /**
   * Use the parameter newMasterProtocol as new current master connection.
   *
   * &lt;i&gt;Lock must be set&lt;/i&gt;
   *
   * @param newMasterProtocol new master connection
   * @throws ReconnectDuringTransactionException if there was an active transaction.
   */
  public void lockAndSwitchMaster(Protocol newMasterProtocol)
      throws ReconnectDuringTransactionException {
<span class="nc bnc" id="L576" title="All 4 branches missed.">    if (masterProtocol != null &amp;&amp; !masterProtocol.isClosed()) {</span>
<span class="nc" id="L577">      masterProtocol.close();</span>
    }

<span class="nc bnc" id="L580" title="All 4 branches missed.">    if (!currentReadOnlyAsked || isSecondaryHostFail()) {</span>
      //actually on a secondary read-only because master was unknown.
      //So select master as currentConnection
<span class="nc bnc" id="L583" title="All 2 branches missed.">      if (currentProtocol != null) {</span>
        try {
<span class="nc" id="L585">          syncConnection(currentProtocol, newMasterProtocol);</span>
<span class="nc" id="L586">        } catch (Exception e) {</span>
          //Some error append during connection parameter synchronisation
<span class="nc" id="L588">        }</span>
      }
      //switching current connection to master connection
<span class="nc" id="L591">      currentProtocol = newMasterProtocol;</span>
    }

<span class="nc bnc" id="L594" title="All 4 branches missed.">    boolean inTransaction = this.masterProtocol != null &amp;&amp; this.masterProtocol.inTransaction();</span>
<span class="nc" id="L595">    this.masterProtocol = newMasterProtocol;</span>
<span class="nc" id="L596">    resetMasterFailoverData();</span>
<span class="nc bnc" id="L597" title="All 2 branches missed.">    if (inTransaction) {</span>
      //master connection was down, so has been change for a new active connection
      //problem was there was an active connection -&gt; must throw exception so client known it
<span class="nc" id="L600">      throw new ReconnectDuringTransactionException(</span>
          &quot;Connection reconnect automatically during an active transaction&quot;, 1401, &quot;25S03&quot;);
    }
<span class="nc" id="L603">  }</span>

  /**
   * Method called when a new secondary connection is found after a fallback.
   *
   * @param newSecondaryProtocol the new active connection
   * @throws SQLException if switch failed
   */
  public void foundActiveSecondary(Protocol newSecondaryProtocol) throws SQLException {
<span class="nc bnc" id="L612" title="All 2 branches missed.">    if (isSecondaryHostFail()) {</span>
<span class="nc bnc" id="L613" title="All 2 branches missed.">      if (isExplicitClosed()) {</span>
<span class="nc" id="L614">        newSecondaryProtocol.close();</span>
<span class="nc" id="L615">        return;</span>
      }

<span class="nc bnc" id="L618" title="All 2 branches missed.">      if (proxy.lock.tryLock()) {</span>
        try {
<span class="nc" id="L620">          lockAndSwitchSecondary(newSecondaryProtocol);</span>
        } finally {
<span class="nc" id="L622">          proxy.lock.unlock();</span>
<span class="nc" id="L623">        }</span>
      } else {
<span class="nc bnc" id="L625" title="All 2 branches missed.">        if (!waitNewSecondaryProtocol.compareAndSet(null, newSecondaryProtocol)) {</span>
<span class="nc" id="L626">          newSecondaryProtocol.close();</span>
        }
      }
    } else {
<span class="nc" id="L630">      newSecondaryProtocol.close();</span>
    }
<span class="nc" id="L632">  }</span>

  /**
   * Use the parameter newSecondaryProtocol as new current secondary connection.
   *
   * @param newSecondaryProtocol new secondary connection
   * @throws SQLException if an error occur during setting session read-only
   */
  public void lockAndSwitchSecondary(Protocol newSecondaryProtocol) throws SQLException {
<span class="nc bnc" id="L641" title="All 4 branches missed.">    if (secondaryProtocol != null &amp;&amp; !secondaryProtocol.isClosed()) {</span>
<span class="nc" id="L642">      secondaryProtocol.close();</span>
    }

    //if asked to be on read only connection, switching to this new connection
<span class="nc bnc" id="L646" title="All 6 branches missed.">    if (currentReadOnlyAsked || (urlParser.getOptions().failOnReadOnly &amp;&amp; !currentReadOnlyAsked</span>
<span class="nc bnc" id="L647" title="All 2 branches missed.">        &amp;&amp; isMasterHostFail())) {</span>
<span class="nc bnc" id="L648" title="All 2 branches missed.">      if (currentProtocol == null) {</span>
        try {
<span class="nc" id="L650">          syncConnection(currentProtocol, newSecondaryProtocol);</span>
<span class="nc" id="L651">        } catch (Exception e) {</span>
          //Some error append during connection parameter synchronisation
<span class="nc" id="L653">        }</span>
      }
<span class="nc" id="L655">      currentProtocol = newSecondaryProtocol;</span>
    }

    //set new found connection as slave connection.
<span class="nc" id="L659">    this.secondaryProtocol = newSecondaryProtocol;</span>
<span class="nc bnc" id="L660" title="All 2 branches missed.">    if (urlParser.getOptions().assureReadOnly) {</span>
<span class="nc" id="L661">      setSessionReadOnly(true, this.secondaryProtocol);</span>
    }

<span class="nc" id="L664">    resetSecondaryFailoverData();</span>
<span class="nc" id="L665">  }</span>

  /**
   * Switch to a read-only(secondary) or read and write connection(master).
   *
   * @param mustBeReadOnly the read-only status asked
   * @throws SQLException if operation hasn't change protocol
   */
  @Override
  public void switchReadOnlyConnection(Boolean mustBeReadOnly) throws SQLException {
<span class="nc" id="L675">    checkWaitingConnection();</span>
<span class="nc bnc" id="L676" title="All 2 branches missed.">    if (currentReadOnlyAsked != mustBeReadOnly) {</span>
<span class="nc" id="L677">      proxy.lock.lock();</span>
      try {
        // another thread updated state
<span class="nc bnc" id="L680" title="All 2 branches missed.">        if (currentReadOnlyAsked == mustBeReadOnly) {</span>
<span class="nc" id="L681">          return;</span>
        }
<span class="nc" id="L683">        currentReadOnlyAsked = mustBeReadOnly;</span>
<span class="nc bnc" id="L684" title="All 2 branches missed.">        if (currentReadOnlyAsked) {</span>
<span class="nc bnc" id="L685" title="All 2 branches missed.">          if (currentProtocol == null) {</span>
            //switching to secondary connection
<span class="nc" id="L687">            currentProtocol = this.secondaryProtocol;</span>
<span class="nc bnc" id="L688" title="All 2 branches missed.">          } else if (currentProtocol.isMasterConnection()) {</span>
            //must change to replica connection
<span class="nc bnc" id="L690" title="All 2 branches missed.">            if (!isSecondaryHostFail()) {</span>
              try {
                //switching to secondary connection
<span class="nc" id="L693">                syncConnection(this.masterProtocol, this.secondaryProtocol);</span>
<span class="nc" id="L694">                currentProtocol = this.secondaryProtocol;</span>
                //current connection is now secondary
<span class="nc" id="L696">                return;</span>
<span class="nc" id="L697">              } catch (SQLException e) {</span>
                //switching to secondary connection failed
<span class="nc bnc" id="L699" title="All 2 branches missed.">                if (setSecondaryHostFail()) {</span>
<span class="nc" id="L700">                  addToBlacklist(secondaryProtocol.getHostAddress());</span>
                }
              }
            }
            //stay on master connection, since slave connection is fail
<span class="nc" id="L705">            FailoverLoop.addListener(this);</span>
          }
        } else {
<span class="nc bnc" id="L708" title="All 2 branches missed.">          if (currentProtocol == null) {</span>
            //switching to master connection
<span class="nc" id="L710">            currentProtocol = this.masterProtocol;</span>
<span class="nc bnc" id="L711" title="All 2 branches missed.">          } else if (!currentProtocol.isMasterConnection()) {</span>
            //must change to master connection
<span class="nc bnc" id="L713" title="All 2 branches missed.">            if (!isMasterHostFail()) {</span>
              try {
                //switching to master connection
<span class="nc" id="L716">                syncConnection(this.secondaryProtocol, this.masterProtocol);</span>
<span class="nc" id="L717">                currentProtocol = this.masterProtocol;</span>
                //current connection is now master
<span class="nc" id="L719">                return;</span>
<span class="nc" id="L720">              } catch (SQLException e) {</span>
                //switching to master connection failed
<span class="nc bnc" id="L722" title="All 2 branches missed.">                if (setMasterHostFail()) {</span>
<span class="nc" id="L723">                  addToBlacklist(masterProtocol.getHostAddress());</span>
                }
<span class="nc" id="L725">              }</span>
<span class="nc bnc" id="L726" title="All 2 branches missed.">            } else if (urlParser.getOptions().allowMasterDownConnection) {</span>
<span class="nc" id="L727">              currentProtocol = null;</span>
<span class="nc" id="L728">              return;</span>
            }

            try {
<span class="nc" id="L732">              reconnectFailedConnection(new SearchFilter(true, false));</span>
<span class="nc" id="L733">              handleFailLoop();</span>

<span class="nc" id="L735">            } catch (SQLException e) {</span>
              //stop failover, since we will throw a connection exception that will close the connection.
<span class="nc" id="L737">              FailoverLoop.removeListener(this);</span>
              HostAddress failHost =
<span class="nc bnc" id="L739" title="All 2 branches missed.">                  (this.masterProtocol != null) ? this.masterProtocol.getHostAddress() : null;</span>
<span class="nc" id="L740">              throwFailoverMessage(failHost, true, new SQLException(&quot;master connection failed&quot;),</span>
                  false);
<span class="nc" id="L742">            }</span>

<span class="nc bnc" id="L744" title="All 2 branches missed.">            if (!isMasterHostFail()) {</span>
              //connection established, no need to send Exception !
              //switching to master connection
              try {
<span class="nc" id="L748">                syncConnection(this.secondaryProtocol, this.masterProtocol);</span>
<span class="nc" id="L749">                currentProtocol = this.masterProtocol;</span>
<span class="nc" id="L750">              } catch (SQLException e) {</span>
                //switching to master connection failed
<span class="nc bnc" id="L752" title="All 2 branches missed.">                if (setMasterHostFail()) {</span>
<span class="nc" id="L753">                  addToBlacklist(masterProtocol.getHostAddress());</span>
                }
<span class="nc" id="L755">              }</span>
            } else {
<span class="nc bnc" id="L757" title="All 2 branches missed.">              currentReadOnlyAsked = !mustBeReadOnly;</span>
              HostAddress failHost =
<span class="nc bnc" id="L759" title="All 2 branches missed.">                  (this.masterProtocol != null) ? this.masterProtocol.getHostAddress() : null;</span>
<span class="nc" id="L760">              throwFailoverMessage(failHost, true, new SQLException(&quot;master connection failed&quot;),</span>
                  false);
            }

          }
        }
      } finally {
<span class="nc" id="L767">        proxy.lock.unlock();</span>
      }
    }
<span class="nc" id="L770">  }</span>

  /**
   * To handle the newly detected failover on the master connection.
   *
   * @param method  the initial called method
   * @param args    the initial args
   * @param killCmd is the fail due to a KILL cmd
   * @return an object to indicate if the previous Exception must be thrown, or the object resulting
   *     if a failover worked
   */
  public HandleErrorResult primaryFail(Method method, Object[] args, boolean killCmd) {
<span class="nc bnc" id="L782" title="All 4 branches missed.">    boolean alreadyClosed = masterProtocol == null || !masterProtocol.isConnected();</span>
<span class="nc bnc" id="L783" title="All 4 branches missed.">    boolean inTransaction = masterProtocol != null &amp;&amp; masterProtocol.inTransaction();</span>

    //in case of SocketTimeoutException due to having set socketTimeout, must force connection close
<span class="nc bnc" id="L786" title="All 4 branches missed.">    if (masterProtocol != null &amp;&amp; masterProtocol.isConnected()) {</span>
<span class="nc" id="L787">      masterProtocol.close();</span>
    }

    //fail on slave if parameter permit so
<span class="nc bnc" id="L791" title="All 4 branches missed.">    if (urlParser.getOptions().failOnReadOnly &amp;&amp; !isSecondaryHostFail()) {</span>
      try {
<span class="nc bnc" id="L793" title="All 4 branches missed.">        if (this.secondaryProtocol != null &amp;&amp; this.secondaryProtocol.ping()) {</span>
          //switching to secondary connection
<span class="nc" id="L795">          proxy.lock.lock();</span>
          try {
<span class="nc bnc" id="L797" title="All 2 branches missed.">            if (masterProtocol != null) {</span>
<span class="nc" id="L798">              syncConnection(masterProtocol, this.secondaryProtocol);</span>
            }
<span class="nc" id="L800">            currentProtocol = this.secondaryProtocol;</span>
          } finally {
<span class="nc" id="L802">            proxy.lock.unlock();</span>
          }
<span class="nc" id="L804">          FailoverLoop.addListener(this);</span>
          try {
<span class="nc" id="L806">            return relaunchOperation(method, args);</span>
<span class="nc" id="L807">          } catch (Exception e) {</span>
            //relaunchOperation failed
          }
<span class="nc" id="L810">          return new HandleErrorResult();</span>
        }
<span class="nc" id="L812">      } catch (Exception e) {</span>
<span class="nc bnc" id="L813" title="All 2 branches missed.">        if (setSecondaryHostFail()) {</span>
<span class="nc" id="L814">          blackListAndCloseConnection(this.secondaryProtocol);</span>
        }
<span class="nc" id="L816">      }</span>
    }

    try {
<span class="nc" id="L820">      reconnectFailedConnection(new SearchFilter(true, urlParser.getOptions().failOnReadOnly));</span>
<span class="nc" id="L821">      handleFailLoop();</span>
<span class="nc bnc" id="L822" title="All 2 branches missed.">      if (currentProtocol != null) {</span>
<span class="nc bnc" id="L823" title="All 2 branches missed.">        if (killCmd) {</span>
<span class="nc" id="L824">          return new HandleErrorResult(true, false);</span>
        }

<span class="nc bnc" id="L827" title="All 8 branches missed.">        if (currentReadOnlyAsked || alreadyClosed || !inTransaction &amp;&amp; isQueryRelaunchable(method,</span>
            args)) {
          //connection was not in transaction

          //can relaunch query
<span class="nc" id="L832">          logger.info(&quot;Connection to master lost, new master {}, conn={} found&quot;</span>
                  + &quot;, query type permit to be re-execute on new server without throwing exception&quot;,
<span class="nc" id="L834">              currentProtocol.getHostAddress(),</span>
<span class="nc" id="L835">              currentProtocol.getServerThreadId());</span>
<span class="nc" id="L836">          return relaunchOperation(method, args);</span>
        }
        //throw Exception because must inform client, even if connection is reconnected
<span class="nc" id="L839">        return new HandleErrorResult(true);</span>
      } else {
<span class="nc" id="L841">        setMasterHostFail();</span>
<span class="nc" id="L842">        FailoverLoop.removeListener(this);</span>
<span class="nc" id="L843">        return new HandleErrorResult();</span>
      }
<span class="nc" id="L845">    } catch (Exception e) {</span>
      //we will throw a Connection exception that will close connection
<span class="nc bnc" id="L847" title="All 2 branches missed.">      if (e.getCause() != null</span>
<span class="nc bnc" id="L848" title="All 4 branches missed.">          &amp;&amp; proxy.hasToHandleFailover((SQLException) e.getCause())</span>
          &amp;&amp; currentProtocol != null
<span class="nc bnc" id="L850" title="All 2 branches missed.">          &amp;&amp; currentProtocol.isConnected()) {</span>
<span class="nc" id="L851">        currentProtocol.close();</span>
      }
<span class="nc" id="L853">      setMasterHostFail();</span>
<span class="nc" id="L854">      FailoverLoop.removeListener(this);</span>
<span class="nc" id="L855">      return new HandleErrorResult();</span>
    }
  }

  private void blackListAndCloseConnection(Protocol protocol) {
<span class="nc" id="L860">    addToBlacklist(protocol.getHostAddress());</span>
<span class="nc bnc" id="L861" title="All 2 branches missed.">    if (protocol.isConnected()) {</span>
<span class="nc" id="L862">      proxy.lock.lock();</span>
      try {
<span class="nc" id="L864">        protocol.close();</span>
      } finally {
<span class="nc" id="L866">        proxy.lock.unlock();</span>
      }
    }
<span class="nc" id="L869">  }</span>

  /**
   * Reconnect failed connection.
   *
   * @throws SQLException if reconnection has failed
   */
  public void reconnect() throws SQLException {
    SearchFilter filter;
<span class="nc" id="L878">    boolean inTransaction = false;</span>
<span class="nc bnc" id="L879" title="All 2 branches missed.">    if (currentReadOnlyAsked) {</span>
<span class="nc" id="L880">      filter = new SearchFilter(true, true);</span>
    } else {
<span class="nc bnc" id="L882" title="All 4 branches missed.">      inTransaction = masterProtocol != null &amp;&amp; masterProtocol.inTransaction();</span>
<span class="nc" id="L883">      filter = new SearchFilter(true, urlParser.getOptions().failOnReadOnly);</span>
    }
<span class="nc" id="L885">    reconnectFailedConnection(filter);</span>
<span class="nc" id="L886">    handleFailLoop();</span>
<span class="nc bnc" id="L887" title="All 2 branches missed.">    if (inTransaction) {</span>
<span class="nc" id="L888">      throw new ReconnectDuringTransactionException(</span>
          &quot;Connection reconnect automatically during an active transaction&quot;, 1401, &quot;25S03&quot;);
    }
<span class="nc" id="L891">  }</span>

  /**
   * Ping secondary protocol. ! lock must be set !
   *
   * @param protocol socket to ping
   * @return true if ping is valid.
   */
  private boolean pingSecondaryProtocol(Protocol protocol) {
    try {
<span class="nc bnc" id="L901" title="All 6 branches missed.">      if (protocol != null &amp;&amp; protocol.isConnected() &amp;&amp; protocol.ping()) {</span>
<span class="nc" id="L902">        return true;</span>
      }
<span class="nc" id="L904">    } catch (Exception e) {</span>
<span class="nc" id="L905">      protocol.close();</span>

<span class="nc bnc" id="L907" title="All 2 branches missed.">      if (setSecondaryHostFail()) {</span>
<span class="nc" id="L908">        addToBlacklist(protocol.getHostAddress());</span>
      }
<span class="nc" id="L910">    }</span>
<span class="nc" id="L911">    return false;</span>
  }

  /**
   * To handle the newly detected failover on the secondary connection.
   *
   * @param method  the initial called method
   * @param args    the initial args
   * @param killCmd is fail due to a KILL command
   * @return an object to indicate if the previous Exception must be thrown, or the object resulting
   *     if a failover worked
   * @throws Throwable if failover has not catch error
   */
  public HandleErrorResult secondaryFail(Method method, Object[] args, boolean killCmd)
      throws Throwable {
<span class="nc" id="L926">    proxy.lock.lock();</span>
    try {
<span class="nc bnc" id="L928" title="All 2 branches missed.">      if (pingSecondaryProtocol(this.secondaryProtocol)) {</span>
<span class="nc" id="L929">        return relaunchOperation(method, args);</span>
      }
    } finally {
<span class="nc" id="L932">      proxy.lock.unlock();</span>
    }

<span class="nc bnc" id="L935" title="All 2 branches missed.">    if (!isMasterHostFail()) {</span>
      try {
        //check that master is on before switching to him
<span class="nc bnc" id="L938" title="All 4 branches missed.">        if (masterProtocol != null &amp;&amp; masterProtocol.isValid(1000)) {</span>
          //switching to master connection
<span class="nc" id="L940">          syncConnection(secondaryProtocol, masterProtocol);</span>
<span class="nc" id="L941">          proxy.lock.lock();</span>
          try {
<span class="nc" id="L943">            currentProtocol = masterProtocol;</span>
          } finally {
<span class="nc" id="L945">            proxy.lock.unlock();</span>
          }
<span class="nc" id="L947">          FailoverLoop.addListener(this);</span>
<span class="nc" id="L948">          logger.info(&quot;Connection to slave lost, using master connection&quot;</span>
              + &quot;, query is re-execute on master server without throwing exception&quot;);
<span class="nc" id="L950">          return relaunchOperation(method,</span>
              args); //now that we are on master, relaunched result if the result was not crashing the master
        }
<span class="nc" id="L953">      } catch (Exception e) {</span>
        //ping fail on master
<span class="nc bnc" id="L955" title="All 2 branches missed.">        if (setMasterHostFail()) {</span>
<span class="nc" id="L956">          blackListAndCloseConnection(masterProtocol);</span>
        }
<span class="nc" id="L958">      }</span>
    }

    try {
<span class="nc" id="L962">      reconnectFailedConnection(new SearchFilter(true, true));</span>
<span class="nc" id="L963">      handleFailLoop();</span>
<span class="nc bnc" id="L964" title="All 2 branches missed.">      if (isSecondaryHostFail()) {</span>
<span class="nc" id="L965">        syncConnection(this.secondaryProtocol, this.masterProtocol);</span>
<span class="nc" id="L966">        proxy.lock.lock();</span>
        try {
<span class="nc" id="L968">          currentProtocol = this.masterProtocol;</span>
        } finally {
<span class="nc" id="L970">          proxy.lock.unlock();</span>
        }
      }

<span class="nc bnc" id="L974" title="All 2 branches missed.">      if (killCmd) {</span>
<span class="nc" id="L975">        return new HandleErrorResult(true, false);</span>
      }

<span class="nc" id="L978">      logger.info(&quot;Connection to slave lost, new slave {}, conn={} found&quot;</span>
              + &quot;, query is re-execute on new server without throwing exception&quot;,
<span class="nc" id="L980">          currentProtocol.getHostAddress(),</span>
<span class="nc" id="L981">          currentProtocol.getServerThreadId());</span>
<span class="nc" id="L982">      return relaunchOperation(method,</span>
          args); //now that we are reconnect, relaunched result if the result was not crashing the node
<span class="nc" id="L984">    } catch (Exception ee) {</span>
      //we will throw a Connection exception that will close connection
<span class="nc" id="L986">      FailoverLoop.removeListener(this);</span>
<span class="nc" id="L987">      return new HandleErrorResult();</span>
    }
  }

  @Override
  public void handleFailLoop() {
<span class="nc bnc" id="L993" title="All 4 branches missed.">    if (isMasterHostFail() || isSecondaryHostFail()) {</span>
<span class="nc bnc" id="L994" title="All 2 branches missed.">      if (!isExplicitClosed()) {</span>
<span class="nc" id="L995">        FailoverLoop.addListener(this);</span>
      }
    } else {
<span class="nc" id="L998">      FailoverLoop.removeListener(this);</span>
    }
<span class="nc" id="L1000">  }</span>

  @Override
  public boolean isMasterConnected() {
<span class="nc bnc" id="L1004" title="All 4 branches missed.">    return masterProtocol != null &amp;&amp; masterProtocol.isConnected();</span>
  }

  /**
   * Indicate if connection has an active transaction.
   *
   * @return boolean
   */
  public boolean inTransaction() {
<span class="nc bnc" id="L1013" title="All 2 branches missed.">    if (masterProtocol != null) {</span>
<span class="nc" id="L1014">      return masterProtocol.inTransaction();</span>
    }
<span class="nc" id="L1016">    return true;</span>
  }

  /**
   * Check master status.
   *
   * @param searchFilter search filter
   * @return has some status changed
   */
  @Override
  public boolean checkMasterStatus(SearchFilter searchFilter) {
<span class="nc bnc" id="L1027" title="All 2 branches missed.">    if (masterProtocol != null) {</span>
<span class="nc" id="L1028">      pingMasterProtocol(masterProtocol);</span>
    }
<span class="nc" id="L1030">    return false;</span>
  }

  @Override
  public void rePrepareOnSlave(ServerPrepareResult oldServerPrepareResult, boolean mustBeOnMaster)
      throws SQLException {
<span class="nc bnc" id="L1036" title="All 2 branches missed.">    if (isSecondaryHostFail()) {</span>
<span class="nc" id="L1037">      Protocol waitingProtocol = waitNewSecondaryProtocol.getAndSet(null);</span>
<span class="nc bnc" id="L1038" title="All 2 branches missed.">      if (waitingProtocol != null) {</span>
<span class="nc" id="L1039">        proxy.lock.lock();</span>
        try {
<span class="nc bnc" id="L1041" title="All 2 branches missed.">          if (pingSecondaryProtocol(waitingProtocol)) {</span>
<span class="nc" id="L1042">            lockAndSwitchSecondary(waitingProtocol);</span>
          }
        } finally {
<span class="nc" id="L1045">          proxy.lock.unlock();</span>
        }
      }
    }

<span class="nc bnc" id="L1050" title="All 4 branches missed.">    if (secondaryProtocol != null &amp;&amp; !isSecondaryHostFail()) {</span>
      //prepare on slave
<span class="nc" id="L1052">      ServerPrepareResult serverPrepareResult = secondaryProtocol</span>
<span class="nc" id="L1053">          .prepare(oldServerPrepareResult.getSql(), mustBeOnMaster);</span>

      //release prepare on master
      try {
<span class="nc" id="L1057">        serverPrepareResult.getUnProxiedProtocol().releasePrepareStatement(serverPrepareResult);</span>
<span class="nc" id="L1058">      } catch (SQLException exception) {</span>
        //released failed.
<span class="nc" id="L1060">      }</span>

      //replace prepare data
<span class="nc" id="L1063">      oldServerPrepareResult.failover(serverPrepareResult.getStatementId(), secondaryProtocol);</span>
    }
<span class="nc" id="L1065">  }</span>

  /**
   * List current connected HostAddress.
   *
   * @return hostAddress List.
   */
  public List&lt;HostAddress&gt; connectedHosts() {
<span class="nc" id="L1073">    List&lt;HostAddress&gt; usedHost = new ArrayList&lt;&gt;();</span>

<span class="nc bnc" id="L1075" title="All 2 branches missed.">    if (isMasterHostFail()) {</span>
<span class="nc" id="L1076">      Protocol masterProtocol = waitNewMasterProtocol.get();</span>
<span class="nc bnc" id="L1077" title="All 2 branches missed.">      if (masterProtocol != null) {</span>
<span class="nc" id="L1078">        usedHost.add(masterProtocol.getHostAddress());</span>
      }
<span class="nc" id="L1080">    } else {</span>
<span class="nc" id="L1081">      usedHost.add(masterProtocol.getHostAddress());</span>
    }

<span class="nc bnc" id="L1084" title="All 2 branches missed.">    if (isSecondaryHostFail()) {</span>
<span class="nc" id="L1085">      Protocol secondProtocol = waitNewSecondaryProtocol.get();</span>
<span class="nc bnc" id="L1086" title="All 2 branches missed.">      if (secondProtocol != null) {</span>
<span class="nc" id="L1087">        usedHost.add(secondProtocol.getHostAddress());</span>
      }
<span class="nc" id="L1089">    } else {</span>
<span class="nc" id="L1090">      usedHost.add(secondaryProtocol.getHostAddress());</span>
    }

<span class="nc" id="L1093">    return usedHost;</span>
  }

  /**
   * Reset state of master and slave connection.
   *
   * @throws SQLException if command fail.
   */
  public void reset() throws SQLException {

<span class="nc bnc" id="L1103" title="All 2 branches missed.">    if (!isMasterHostFail()) {</span>
<span class="nc" id="L1104">      masterProtocol.reset();</span>
    }

<span class="nc bnc" id="L1107" title="All 2 branches missed.">    if (!isSecondaryHostFail()) {</span>
<span class="nc" id="L1108">      secondaryProtocol.reset();</span>
    }
<span class="nc" id="L1110">  }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>