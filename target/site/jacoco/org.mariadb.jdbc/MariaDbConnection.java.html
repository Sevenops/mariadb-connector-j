<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="tr"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>MariaDbConnection.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">mariadb-java-client</a> &gt; <a href="index.source.html" class="el_package">org.mariadb.jdbc</a> &gt; <span class="el_source">MariaDbConnection.java</span></div><h1>MariaDbConnection.java</h1><pre class="source lang-java linenums">/*
 *
 * MariaDB Client for Java
 *
 * Copyright (c) 2012-2014 Monty Program Ab.
 * Copyright (c) 2015-2017 MariaDB Ab.
 *
 * This library is free software; you can redistribute it and/or modify it under
 * the terms of the GNU Lesser General Public License as published by the Free
 * Software Foundation; either version 2.1 of the License, or (at your option)
 * any later version.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
 * for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License along
 * with this library; if not, write to Monty Program Ab info@montyprogram.com.
 *
 * This particular MariaDB Client for Java file is work
 * derived from a Drizzle-JDBC. Drizzle-JDBC file which is covered by subject to
 * the following copyright and notice provisions:
 *
 * Copyright (c) 2009-2011, Marcus Eriksson
 *
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 * Redistributions of source code must retain the above copyright notice, this list
 * of conditions and the following disclaimer.
 *
 * Redistributions in binary form must reproduce the above copyright notice, this
 * list of conditions and the following disclaimer in the documentation and/or
 * other materials provided with the distribution.
 *
 * Neither the name of the driver nor the names of its contributors may not be
 * used to endorse or promote products derived from this software without specific
 * prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS  AND CONTRIBUTORS &quot;AS IS&quot;
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
 * OF SUCH DAMAGE.
 *
 */

package org.mariadb.jdbc;

import java.net.SocketException;
import java.sql.Array;
import java.sql.Blob;
import java.sql.CallableStatement;
import java.sql.ClientInfoStatus;
import java.sql.Clob;
import java.sql.Connection;
import java.sql.DatabaseMetaData;
import java.sql.NClob;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLClientInfoException;
import java.sql.SQLException;
import java.sql.SQLNonTransientConnectionException;
import java.sql.SQLPermission;
import java.sql.SQLSyntaxErrorException;
import java.sql.SQLWarning;
import java.sql.SQLXML;
import java.sql.Savepoint;
import java.sql.Statement;
import java.sql.Struct;
import java.util.HashMap;
import java.util.Map;
import java.util.Properties;
import java.util.concurrent.Executor;
import java.util.concurrent.locks.ReentrantLock;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import org.mariadb.jdbc.internal.logging.Logger;
import org.mariadb.jdbc.internal.logging.LoggerFactory;
import org.mariadb.jdbc.internal.protocol.Protocol;
import org.mariadb.jdbc.internal.util.CallableStatementCache;
import org.mariadb.jdbc.internal.util.ConnectionState;
import org.mariadb.jdbc.internal.util.Options;
import org.mariadb.jdbc.internal.util.Utils;
import org.mariadb.jdbc.internal.util.dao.CallableStatementCacheKey;
import org.mariadb.jdbc.internal.util.dao.CloneableCallableStatement;
import org.mariadb.jdbc.internal.util.exceptions.ExceptionMapper;
import org.mariadb.jdbc.internal.util.pool.GlobalStateInfo;
import org.mariadb.jdbc.internal.util.pool.Pools;


@SuppressWarnings(&quot;Annotator&quot;)
public class MariaDbConnection implements Connection {

<span class="nc" id="L100">  private static final Logger logger = LoggerFactory.getLogger(MariaDbConnection.class);</span>

  /**
   * Pattern  to check the correctness of callable statement query string Legal queries, as
   * documented in JDK have the form: {[?=]call[(arg1,..,,argn)]}
   */
<span class="nc" id="L106">  private static final Pattern CALLABLE_STATEMENT_PATTERN =</span>
<span class="nc" id="L107">      Pattern.compile(&quot;^(\\s*\\{)?\\s*((\\?\\s*=)?(\\s*\\/\\*([^\\*]|\\*[^\\/])*\\*\\/)*\\s*&quot;</span>
              + &quot;call(\\s*\\/\\*([^\\*]|\\*[^\\/])*\\*\\/)*\\s*((((`[^`]+`)|([^`\\}]+))\\.)?&quot;
              + &quot;((`[^`]+`)|([^`\\}\\(]+)))\\s*(\\(.*\\))?(\\s*\\/\\*([^\\*]|\\*[^\\/])*\\*\\/)*&quot;
              + &quot;\\s*(#.*)?)\\s*(\\}\\s*)?$&quot;,
          Pattern.CASE_INSENSITIVE | Pattern.DOTALL);
  /**
   * Check that query can be executed with PREPARE.
   */
<span class="nc" id="L115">  private static final Pattern PREPARABLE_STATEMENT_PATTERN =</span>
<span class="nc" id="L116">      Pattern.compile(</span>
          &quot;^(\\s*\\/\\*([^\\*]|\\*[^\\/])*\\*\\/)*\\s*(SELECT|UPDATE|INSERT|DELETE|REPLACE|DO|CALL)&quot;,
          Pattern.CASE_INSENSITIVE);
  public final ReentrantLock lock;
  /**
   * the protocol to communicate with.
   */
  private final Protocol protocol;
  /**
   * the properties for the client.
   */
  private final Options options;
  public MariaDbPooledConnection pooledConnection;
  protected boolean nullCatalogMeansCurrent;
  private CallableStatementCache callableStatementCache;
<span class="nc" id="L131">  private volatile int lowercaseTableNames = -1;</span>
  private boolean canUseServerTimeout;
  private boolean sessionStateAware;
<span class="nc" id="L134">  private int stateFlag = 0;</span>
<span class="nc" id="L135">  private int defaultTransactionIsolation = 0;</span>
  /**
   * save point count - to generate good names for the savepoints.
   */
<span class="nc" id="L139">  private int savepointCount = 0;</span>
  private boolean warningsCleared;

  /**
   * Creates a new connection with a given protocol and query factory.
   *
   * @param protocol the protocol to use.
   */
<span class="nc" id="L147">  public MariaDbConnection(Protocol protocol) {</span>
<span class="nc" id="L148">    this.protocol = protocol;</span>
<span class="nc" id="L149">    options = protocol.getOptions();</span>
<span class="nc" id="L150">    canUseServerTimeout = protocol.versionGreaterOrEqual(10, 1, 2);</span>
<span class="nc" id="L151">    sessionStateAware = protocol.sessionStateAware();</span>
<span class="nc" id="L152">    nullCatalogMeansCurrent = options.nullCatalogMeansCurrent;</span>
<span class="nc bnc" id="L153" title="All 2 branches missed.">    if (options.cacheCallableStmts) {</span>
<span class="nc" id="L154">      callableStatementCache = CallableStatementCache.newInstance(options.callableStmtCacheSize);</span>
    }
<span class="nc" id="L156">    this.lock = protocol.getLock();</span>

<span class="nc" id="L158">  }</span>

  /**
   * Create new connection Object.
   *
   * @param urlParser  parser
   * @param globalInfo global info
   * @return connection object
   * @throws SQLException if any connection error occur
   */
  public static MariaDbConnection newConnection(UrlParser urlParser, GlobalStateInfo globalInfo)
      throws SQLException {
<span class="nc bnc" id="L170" title="All 2 branches missed.">    if (urlParser.getOptions().pool) {</span>
<span class="nc" id="L171">      return Pools.retrievePool(urlParser).getConnection();</span>
    }

<span class="nc" id="L174">    Protocol protocol = Utils.retrieveProxy(urlParser, globalInfo);</span>
<span class="nc" id="L175">    return new MariaDbConnection(protocol);</span>
  }

  public static String quoteIdentifier(String string) {
<span class="nc" id="L179">    return &quot;`&quot; + string.replaceAll(&quot;`&quot;, &quot;``&quot;) + &quot;`&quot;;</span>
  }

  /**
   * UnQuote string.
   *
   * @param string value
   * @return unquote string
   * @deprecated since 1.3.0
   */
  @Deprecated
  public static String unquoteIdentifier(String string) {
<span class="nc bnc" id="L191" title="All 8 branches missed.">    if (string != null &amp;&amp; string.startsWith(&quot;`&quot;) &amp;&amp; string.endsWith(&quot;`&quot;) &amp;&amp; string.length() &gt;= 2) {</span>
<span class="nc" id="L192">      return string.substring(1, string.length() - 1).replace(&quot;``&quot;, &quot;`&quot;);</span>
    }
<span class="nc" id="L194">    return string;</span>
  }

  protected Protocol getProtocol() {
<span class="nc" id="L198">    return protocol;</span>
  }

  /**
   * creates a new statement.
   *
   * @return a statement
   * @throws SQLException if we cannot create the statement.
   */
  public Statement createStatement() throws SQLException {
<span class="nc" id="L208">    checkConnection();</span>
<span class="nc" id="L209">    return new MariaDbStatement(this, ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY);</span>
  }

  /**
   * Creates a &lt;code&gt;Statement&lt;/code&gt; object that will generate &lt;code&gt;ResultSet&lt;/code&gt; objects with
   * the given type and concurrency. This method is the same as the &lt;code&gt;createStatement&lt;/code&gt;
   * method above, but it allows the default result set type and concurrency to be overridden. The
   * holdability of the created result sets can be determined by calling {@link #getHoldability}.
   *
   * @param resultSetType        a result set type; one of &lt;code&gt;ResultSet.TYPE_FORWARD_ONLY&lt;/code&gt;,
   *                             &lt;code&gt;ResultSet.TYPE_SCROLL_INSENSITIVE&lt;/code&gt;, or
   *                             &lt;code&gt;ResultSet.TYPE_SCROLL_SENSITIVE&lt;/code&gt;
   * @param resultSetConcurrency a concurrency type; one of &lt;code&gt;ResultSet.CONCUR_READ_ONLY&lt;/code&gt;
   *                             or
   *                             &lt;code&gt;ResultSet.CONCUR_UPDATABLE&lt;/code&gt;
   * @return a new &lt;code&gt;Statement&lt;/code&gt; object that will generate &lt;code&gt;ResultSet&lt;/code&gt; objects
   *     with the given type and concurrency
   */
  public Statement createStatement(final int resultSetType, final int resultSetConcurrency) {
<span class="nc" id="L228">    return new MariaDbStatement(this, resultSetType, resultSetConcurrency);</span>
  }

  /**
   * Creates a &lt;code&gt;Statement&lt;/code&gt; object that will generate &lt;code&gt;ResultSet&lt;/code&gt; objects with
   * the given type, concurrency, and holdability. This method is the same as the
   * &lt;code&gt;createStatement&lt;/code&gt; method above, but it allows the default result set type,
   * concurrency, and holdability to be overridden.
   *
   * @param resultSetType        one of the following &lt;code&gt;ResultSet&lt;/code&gt; constants:
   *                             &lt;code&gt;ResultSet.TYPE_FORWARD_ONLY&lt;/code&gt;,
   *                             &lt;code&gt;ResultSet.TYPE_SCROLL_INSENSITIVE&lt;/code&gt;, or
   *                             &lt;code&gt;ResultSet.TYPE_SCROLL_SENSITIVE&lt;/code&gt;
   * @param resultSetConcurrency one of the following &lt;code&gt;ResultSet&lt;/code&gt; constants:
   *                             &lt;code&gt;ResultSet.CONCUR_READ_ONLY&lt;/code&gt; or
   *                             &lt;code&gt;ResultSet.CONCUR_UPDATABLE&lt;/code&gt;
   * @param resultSetHoldability one of the following &lt;code&gt;ResultSet&lt;/code&gt; constants:
   *                             &lt;code&gt;ResultSet.HOLD_CURSORS_OVER_COMMIT&lt;/code&gt; or
   *                             &lt;code&gt;ResultSet.CLOSE_CURSORS_AT_COMMIT&lt;/code&gt;
   * @return a new &lt;code&gt;Statement&lt;/code&gt; object that will generate &lt;code&gt;ResultSet&lt;/code&gt; objects
   *      with the given type, concurrency, and holdability
   * @see ResultSet
   */
  public Statement createStatement(final int resultSetType, final int resultSetConcurrency,
      final int resultSetHoldability) {
<span class="nc" id="L253">    return new MariaDbStatement(this, resultSetType, resultSetConcurrency);</span>
  }

  private void checkConnection() throws SQLException {
<span class="nc bnc" id="L257" title="All 2 branches missed.">    if (protocol.isExplicitClosed()) {</span>
<span class="nc" id="L258">      throw new SQLException(&quot;createStatement() is called on closed connection&quot;);</span>
    }
<span class="nc bnc" id="L260" title="All 4 branches missed.">    if (protocol.isClosed() &amp;&amp; protocol.getProxy() != null) {</span>
<span class="nc" id="L261">      lock.lock();</span>
      try {
<span class="nc" id="L263">        protocol.getProxy().reconnect();</span>
      } finally {
<span class="nc" id="L265">        lock.unlock();</span>
      }
    }
<span class="nc" id="L268">  }</span>

  /**
   * Create a new client prepared statement.
   *
   * @param sql the query.
   * @return a client prepared statement.
   * @throws SQLException if there is a problem preparing the statement.
   */
  public ClientSidePreparedStatement clientPrepareStatement(final String sql)
      throws SQLException {
<span class="nc" id="L279">    return new ClientSidePreparedStatement(this,</span>
        sql,
        ResultSet.TYPE_FORWARD_ONLY,
        ResultSet.CONCUR_READ_ONLY,
        Statement.RETURN_GENERATED_KEYS);
  }

  /**
   * Create a new server prepared statement.
   *
   * @param sql the query.
   * @return a server prepared statement.
   * @throws SQLException if there is a problem preparing the statement.
   */
  public ServerSidePreparedStatement serverPrepareStatement(final String sql)
      throws SQLException {
<span class="nc" id="L295">    return new ServerSidePreparedStatement(this,</span>
        sql,
        ResultSet.TYPE_FORWARD_ONLY,
        ResultSet.CONCUR_READ_ONLY,
        Statement.RETURN_GENERATED_KEYS);
  }

  /**
   * creates a new prepared statement.
   *
   * @param sql the query.
   * @return a prepared statement.
   * @throws SQLException if there is a problem preparing the statement.
   */
  public PreparedStatement prepareStatement(final String sql) throws SQLException {
<span class="nc" id="L310">    return internalPrepareStatement(sql,</span>
        ResultSet.TYPE_FORWARD_ONLY,
        ResultSet.CONCUR_READ_ONLY,
        Statement.NO_GENERATED_KEYS);
  }


  /**
   * Creates a &lt;code&gt;PreparedStatement&lt;/code&gt; object that will generate &lt;code&gt;ResultSet&lt;/code&gt;
   * objects with the given type and concurrency. This method is the same as the
   * &lt;code&gt;prepareStatement&lt;/code&gt; method above, but it allows the default result set type and
   * concurrency to be overridden. The holdability of the created result sets can be determined by
   * calling {@link #getHoldability}.
   *
   * @param sql                  a &lt;code&gt;String&lt;/code&gt; object that is the SQL statement to be sent
   *                             to the database; may contain one or more '?' IN parameters
   * @param resultSetType        a result set type; one of &lt;code&gt;ResultSet.TYPE_FORWARD_ONLY&lt;/code&gt;,
   *                             &lt;code&gt;ResultSet.TYPE_SCROLL_INSENSITIVE&lt;/code&gt;, or
   *                             &lt;code&gt;ResultSet.TYPE_SCROLL_SENSITIVE&lt;/code&gt;
   * @param resultSetConcurrency a concurrency type; one of &lt;code&gt;ResultSet.CONCUR_READ_ONLY&lt;/code&gt;
   *                             or
   *                             &lt;code&gt;ResultSet.CONCUR_UPDATABLE&lt;/code&gt;
   * @return a new PreparedStatement object containing the pre-compiled SQL statement that will
   *     produce &lt;code&gt;ResultSet&lt;/code&gt; objects with the given type and concurrency
   * @throws SQLException if a database access error occurs, this method is called on a closed
   *                      connection or the given parameters are not&lt;code&gt;ResultSet&lt;/code&gt; constants
   *                      indicating type and concurrency
   */
  public PreparedStatement prepareStatement(final String sql, final int resultSetType,
      final int resultSetConcurrency)
      throws SQLException {
<span class="nc" id="L341">    return internalPrepareStatement(sql,</span>
        resultSetType,
        resultSetConcurrency,
        Statement.NO_GENERATED_KEYS);
  }

  /**
   * &lt;p&gt;Creates a &lt;code&gt;PreparedStatement&lt;/code&gt; object that will generate &lt;code&gt;ResultSet&lt;/code&gt;
   * objects with the given type, concurrency, and holdability.&lt;/p&gt;
   * &lt;p&gt;This method is the same as the &lt;code&gt;prepareStatement&lt;/code&gt; method above, but it allows
   * the default result set type, concurrency, and holdability to be overridden.&lt;/p&gt;
   *
   * @param sql                  a &lt;code&gt;String&lt;/code&gt; object that is the SQL statement to be sent
   *                             to the database; may contain one or more '?' IN parameters
   * @param resultSetType        one of the following &lt;code&gt;ResultSet&lt;/code&gt; constants:
   *                             &lt;code&gt;ResultSet.TYPE_FORWARD_ONLY&lt;/code&gt;,
   *                             &lt;code&gt;ResultSet.TYPE_SCROLL_INSENSITIVE&lt;/code&gt;, or
   *                             &lt;code&gt;ResultSet.TYPE_SCROLL_SENSITIVE&lt;/code&gt;
   * @param resultSetConcurrency one of the following &lt;code&gt;ResultSet&lt;/code&gt; constants:
   *                             &lt;code&gt;ResultSet.CONCUR_READ_ONLY&lt;/code&gt; or
   *                             &lt;code&gt;ResultSet.CONCUR_UPDATABLE&lt;/code&gt;
   * @param resultSetHoldability one of the following &lt;code&gt;ResultSet&lt;/code&gt; constants:
   *                             &lt;code&gt;ResultSet.HOLD_CURSORS_OVER_COMMIT&lt;/code&gt; or
   *                             &lt;code&gt;ResultSet.CLOSE_CURSORS_AT_COMMIT&lt;/code&gt;
   * @return a new &lt;code&gt;PreparedStatement&lt;/code&gt; object, containing the pre-compiled SQL statement,
   *     that will generate &lt;code&gt;ResultSet&lt;/code&gt; objects with the given type, concurrency, and
   *     holdability
   * @throws SQLException                    if a database access error occurs, this method is
   *                                         called on a closed connection or the given parameters
   *                                         are not
   *                                         &lt;code&gt;ResultSet&lt;/code&gt; constants indicating type,
   *                                         concurrency, and holdability
   * @see ResultSet
   */
  public PreparedStatement prepareStatement(final String sql,
                                            final int resultSetType,
                                            final int resultSetConcurrency,
                                            final int resultSetHoldability) throws SQLException {
<span class="nc" id="L379">    return internalPrepareStatement(sql,</span>
        resultSetType,
        resultSetConcurrency,
        Statement.NO_GENERATED_KEYS);
  }

  /**
   * &lt;p&gt;Creates a default &lt;code&gt;PreparedStatement&lt;/code&gt; object that has the capability to retrieve
   * auto-generated keys. The given constant tells the driver whether it should make auto-generated
   * keys available for retrieval.  This parameter is ignored if the SQL statement is not an
   * &lt;code&gt;INSERT&lt;/code&gt; statement, or an SQL statement able to return auto-generated keys (the
   * list of such statements is vendor-specific).&lt;/p&gt;
   * &lt;p&gt;&lt;B&gt;Note:&lt;/B&gt; This method is optimized for handling parametric SQL statements that benefit
   * from precompilation. If the driver supports precompilation, the method
   * &lt;code&gt;prepareStatement&lt;/code&gt; will send the statement to the database for precompilation. Some
   * drivers may not support precompilation. In this case, the statement may not be sent to the
   * database until the &lt;code&gt;PreparedStatement&lt;/code&gt; object is executed.  This has no direct
   * effect on users; however, it does affect which methods throw certain SQLExceptions.&lt;/p&gt;
   * &lt;p&gt;Result sets created using the returned &lt;code&gt;PreparedStatement&lt;/code&gt; object will by
   * default be type &lt;code&gt;TYPE_FORWARD_ONLY&lt;/code&gt; and have a concurrency level of
   * &lt;code&gt;CONCUR_READ_ONLY&lt;/code&gt;. The holdability of the created result sets can be determined by
   * calling {@link #getHoldability}.&lt;/p&gt;
   *
   * @param sql               an SQL statement that may contain one or more '?' IN parameter
   *                          placeholders
   * @param autoGeneratedKeys a flag indicating whether auto-generated keys should be returned; one
   *                          of
   *                          &lt;code&gt;Statement.RETURN_GENERATED_KEYS&lt;/code&gt;
   *                          or &lt;code&gt;Statement.NO_GENERATED_KEYS&lt;/code&gt;
   * @return a new &lt;code&gt;PreparedStatement&lt;/code&gt; object, containing the pre-compiled SQL statement,
   *     that will have the capability of returning auto-generated keys
   * @throws SQLException                    if a database access error occurs, this method is
   *                                         called on a closed connection or the given parameter is
   *                                         not a &lt;code&gt;Statement&lt;/code&gt; constant indicating
   *                                         whether auto-generated keys should be returned
   */
  public PreparedStatement prepareStatement(final String sql, final int autoGeneratedKeys)
      throws SQLException {
<span class="nc" id="L417">    return internalPrepareStatement(sql,</span>
        ResultSet.TYPE_FORWARD_ONLY,
        ResultSet.CONCUR_READ_ONLY,
        autoGeneratedKeys);
  }

  /**
   * &lt;p&gt;Creates a default &lt;code&gt;PreparedStatement&lt;/code&gt; object capable of returning the
   * auto-generated keys designated by the given array. This array contains the indexes of the
   * columns in the target table that contain the auto-generated keys that should be made available.
   * The driver will ignore the array if the SQL statement is not an &lt;code&gt;INSERT&lt;/code&gt; statement,
   * or an SQL statement able to return auto-generated keys (the list of such statements is
   * vendor-specific).&lt;/p&gt;
   * &lt;p&gt;An SQL statement with or without IN parameters can be pre-compiled and stored in a
   * &lt;code&gt;PreparedStatement&lt;/code&gt; object. This object can
   * then be used to efficiently execute this statement multiple times.&lt;/p&gt;
   * &lt;p&gt;&lt;B&gt;Note:&lt;/B&gt; This method is optimized for handling parametric SQL statements that benefit
   * from precompilation. If the driver supports precompilation, the method
   * &lt;code&gt;prepareStatement&lt;/code&gt; will send the statement to the database for precompilation. Some
   * drivers may not support precompilation. In this case, the statement may not be sent to the
   * database until the &lt;code&gt;PreparedStatement&lt;/code&gt; object is executed.  This has no direct
   * effect on users; however, it does affect which methods throw certain SQLExceptions.&lt;/p&gt;
   * &lt;p&gt;
   * Result sets created using the returned &lt;code&gt;PreparedStatement&lt;/code&gt; object will by default be
   * type &lt;code&gt;TYPE_FORWARD_ONLY&lt;/code&gt; and have a concurrency level of
   * &lt;code&gt;CONCUR_READ_ONLY&lt;/code&gt;. The holdability of the created result sets can be determined by
   * calling {@link #getHoldability}.&lt;/p&gt;
   *
   * @param sql           an SQL statement that may contain one or more '?' IN parameter
   *                      placeholders
   * @param columnIndexes an array of column indexes indicating the columns that should be returned
   *                      from the inserted row or rows
   * @return a new &lt;code&gt;PreparedStatement&lt;/code&gt; object, containing the pre-compiled statement,
   *     that is capable of returning the auto-generated keys designated by the given array of
   *     column indexes
   * @throws SQLException                    if a database access error occurs or this method is
   *                                         called on a closed connection
   */
  public PreparedStatement prepareStatement(final String sql, final int[] columnIndexes)
      throws SQLException {
<span class="nc" id="L457">    return prepareStatement(sql, Statement.RETURN_GENERATED_KEYS);</span>
  }

  /**
   * &lt;p&gt;Creates a default &lt;code&gt;PreparedStatement&lt;/code&gt; object capable of returning the
   * auto-generated keys designated by the given array. This array contains the names of the columns
   * in the target table that contain the auto-generated keys that should be returned. The driver
   * will ignore the array if the SQL statement is not an &lt;code&gt;INSERT&lt;/code&gt; statement, or an SQL
   * statement able to return auto-generated keys (the list of such statements is
   * vendor-specific).&lt;/p&gt;
   * &lt;p&gt;An SQL statement with or without IN parameters can be pre-compiled and stored in a
   * &lt;code&gt;PreparedStatement&lt;/code&gt; object. This object can
   * then be used to efficiently execute this statement multiple times.&lt;/p&gt;
   * &lt;p&gt;&lt;B&gt;Note:&lt;/B&gt; This method is optimized for handling parametric SQL statements that benefit
   * from precompilation. If the driver supports precompilation, the method
   * &lt;code&gt;prepareStatement&lt;/code&gt; will send the statement to the database for precompilation. Some
   * drivers may not support precompilation. In this case, the statement may not be sent to the
   * database until the &lt;code&gt;PreparedStatement&lt;/code&gt; object is executed.  This has no direct
   * effect on users; however, it does affect which methods throw certain SQLExceptions.&lt;/p&gt;
   * &lt;p&gt;Result sets created using the returned &lt;code&gt;PreparedStatement&lt;/code&gt; object will by
   * default be type &lt;code&gt;TYPE_FORWARD_ONLY&lt;/code&gt; and have a concurrency level of
   * &lt;code&gt;CONCUR_READ_ONLY&lt;/code&gt;. The holdability of the created result sets can be determined by
   * calling {@link #getHoldability}.&lt;/p&gt;
   *
   * @param sql         an SQL statement that may contain one or more '?' IN parameter placeholders
   * @param columnNames an array of column names indicating the columns that should be returned from
   *                    the inserted row or rows
   * @return a new &lt;code&gt;PreparedStatement&lt;/code&gt; object, containing the pre-compiled statement,
   *     that is capable of returning the auto-generated keys designated by the given array of
   *     column names
   * @throws SQLException                    if a database access error occurs or this method is
   *                                         called on a closed connection
   */
  public PreparedStatement prepareStatement(final String sql, final String[] columnNames)
      throws SQLException {
<span class="nc" id="L492">    return prepareStatement(sql, Statement.RETURN_GENERATED_KEYS);</span>
  }


  /**
   * Send ServerPrepareStatement or ClientPrepareStatement depending on SQL query and options If
   * server side and PREPARE can be delayed, a facade will be return, to have a fallback on client
   * prepareStatement.
   *
   * @param sql                  sql query
   * @param resultSetScrollType  one of the following &lt;code&gt;ResultSet&lt;/code&gt; constants:
   *                             &lt;code&gt;ResultSet.TYPE_FORWARD_ONLY&lt;/code&gt;,
   *                             &lt;code&gt;ResultSet.TYPE_SCROLL_INSENSITIVE&lt;/code&gt;, or
   *                             &lt;code&gt;ResultSet.TYPE_SCROLL_SENSITIVE&lt;/code&gt;
   * @param resultSetConcurrency a concurrency type; one of &lt;code&gt;ResultSet.CONCUR_READ_ONLY&lt;/code&gt;
   *                             or
   *                             &lt;code&gt;ResultSet.CONCUR_UPDATABLE&lt;/code&gt;
   * @param autoGeneratedKeys    a flag indicating whether auto-generated keys should be returned;
   *                             one of
   *                             &lt;code&gt;Statement.RETURN_GENERATED_KEYS&lt;/code&gt;
   *                             or &lt;code&gt;Statement.NO_GENERATED_KEYS&lt;/code&gt;
   * @return PrepareStatement
   * @throws SQLException if a connection error occur during the server preparation.
   */
  private PreparedStatement internalPrepareStatement(final String sql,
      final int resultSetScrollType,
      final int resultSetConcurrency,
      final int autoGeneratedKeys)
      throws SQLException {

<span class="nc bnc" id="L522" title="All 2 branches missed.">    if (sql != null) {</span>

<span class="nc" id="L524">      String sqlQuery = Utils.nativeSql(sql, protocol.noBackslashEscapes());</span>

<span class="nc bnc" id="L526" title="All 4 branches missed.">      if (options.useServerPrepStmts &amp;&amp; PREPARABLE_STATEMENT_PATTERN.matcher(sqlQuery).find()) {</span>
        //prepare isn't delayed -&gt; if prepare fail, fallback to client preparedStatement?
<span class="nc" id="L528">        checkConnection();</span>
        try {
<span class="nc" id="L530">          return new ServerSidePreparedStatement(this,</span>
              sqlQuery,
              resultSetScrollType,
              resultSetConcurrency,
              autoGeneratedKeys);
<span class="nc" id="L535">        } catch (SQLNonTransientConnectionException e) {</span>
<span class="nc" id="L536">          throw e;</span>
<span class="nc" id="L537">        } catch (SQLException e) {</span>
          //on some specific case, server cannot prepared data (CONJ-238)
          //will use clientPreparedStatement
        }
      }
<span class="nc" id="L542">      return new ClientSidePreparedStatement(this,</span>
          sqlQuery,
          resultSetScrollType,
          resultSetConcurrency,
          autoGeneratedKeys);
    } else {
<span class="nc" id="L548">      throw new SQLException(&quot;SQL value can not be NULL&quot;);</span>
    }
  }

  /**
   * Creates a &lt;code&gt;CallableStatement&lt;/code&gt; object for calling database stored procedures. The
   * &lt;code&gt;CallableStatement&lt;/code&gt; object provides methods for setting up its IN and OUT
   * parameters, and methods for executing the call to a stored procedure. example : {?= call
   * &amp;lt;procedure-name&amp;gt;[(&amp;lt;arg1&amp;gt;,&amp;lt;arg2&amp;gt;, ...)]} or {call
   * &amp;lt;procedure-name&amp;gt;[(&amp;lt;arg1&amp;gt;,&amp;lt;arg2&amp;gt;, ...)]}
   * &lt;p&gt;
   * &lt;b&gt;Note:&lt;/b&gt; This method is optimized for handling stored
   * procedure call statements.
   * &lt;/p&gt;
   *
   * @param sql an SQL statement that may contain one or more '?' parameter placeholders. Typically
   *            this statement is specified using JDBC call escape syntax.
   * @return a new default &lt;code&gt;CallableStatement&lt;/code&gt; object containing the pre-compiled SQL
   *     statement
   * @throws SQLException if a database access error occurs or this method is called on a closed
   *                      connection
   */
  public CallableStatement prepareCall(final String sql) throws SQLException {
<span class="nc" id="L571">    return prepareCall(sql, ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY);</span>
  }


  /**
   * Creates a &lt;code&gt;CallableStatement&lt;/code&gt; object that will generate &lt;code&gt;ResultSet&lt;/code&gt;
   * objects with the given type and concurrency. This method is the same as the
   * &lt;code&gt;prepareCall&lt;/code&gt; method above, but it allows the default result set type and
   * concurrency to be overridden. The holdability of the created result sets can be determined by
   * calling {@link #getHoldability}.
   *
   * @param sql                  a &lt;code&gt;String&lt;/code&gt; object that is the SQL statement to be sent
   *                             to the database; may contain on or more '?' parameters
   * @param resultSetType        a result set type; one of &lt;code&gt;ResultSet.TYPE_FORWARD_ONLY&lt;/code&gt;,
   *                             &lt;code&gt;ResultSet.TYPE_SCROLL_INSENSITIVE&lt;/code&gt;, or
   *                             &lt;code&gt;ResultSet.TYPE_SCROLL_SENSITIVE&lt;/code&gt;
   * @param resultSetConcurrency a concurrency type; one of &lt;code&gt;ResultSet.CONCUR_READ_ONLY&lt;/code&gt;
   *                             or
   *                             &lt;code&gt;ResultSet.CONCUR_UPDATABLE&lt;/code&gt;
   * @return a new &lt;code&gt;CallableStatement&lt;/code&gt; object containing the pre-compiled SQL statement
   *     that will produce
   *     &lt;code&gt;ResultSet&lt;/code&gt; objects with the given type and concurrency
   * @throws SQLException                    if a database access error occurs, this method is
   *                                         called on a closed connection or the given parameters
   *                                         are not
   *                                         &lt;code&gt;ResultSet&lt;/code&gt; constants indicating type and
   *                                         concurrency
   */
  public CallableStatement prepareCall(final String sql, final int resultSetType,
      final int resultSetConcurrency) throws SQLException {
<span class="nc" id="L601">    checkConnection();</span>

<span class="nc" id="L603">    Matcher matcher = CALLABLE_STATEMENT_PATTERN.matcher(sql);</span>
<span class="nc bnc" id="L604" title="All 2 branches missed.">    if (!matcher.matches()) {</span>
<span class="nc" id="L605">      throw new SQLSyntaxErrorException(</span>
          &quot;invalid callable syntax. must be like {[?=]call &lt;procedure/function name&gt;[(?,?, ...)]}\n but was : &quot;
              + sql);
    }

<span class="nc" id="L610">    String query = Utils.nativeSql(matcher.group(2), protocol.noBackslashEscapes());</span>

<span class="nc bnc" id="L612" title="All 2 branches missed.">    boolean isFunction = (matcher.group(3) != null);</span>
<span class="nc" id="L613">    String databaseAndProcedure = matcher.group(8);</span>
<span class="nc" id="L614">    String database = matcher.group(10);</span>
<span class="nc" id="L615">    String procedureName = matcher.group(13);</span>
<span class="nc" id="L616">    String arguments = matcher.group(16);</span>
<span class="nc bnc" id="L617" title="All 4 branches missed.">    if (database == null &amp;&amp; sessionStateAware) {</span>
<span class="nc" id="L618">      database = protocol.getDatabase();</span>
    }

<span class="nc bnc" id="L621" title="All 4 branches missed.">    if (database != null &amp;&amp; options.cacheCallableStmts) {</span>

<span class="nc bnc" id="L623" title="All 2 branches missed.">      if (callableStatementCache.containsKey(new CallableStatementCacheKey(database, query))) {</span>
        try {
<span class="nc" id="L625">          CallableStatement callableStatement = callableStatementCache</span>
<span class="nc" id="L626">              .get(new CallableStatementCacheKey(database, query));</span>
<span class="nc bnc" id="L627" title="All 2 branches missed.">          if (callableStatement != null) {</span>
            //Clone to avoid side effect like having some open resultSet.
<span class="nc" id="L629">            return ((CloneableCallableStatement) callableStatement).clone(this);</span>
          }
<span class="nc" id="L631">        } catch (CloneNotSupportedException cloneNotSupportedException) {</span>
<span class="nc" id="L632">          cloneNotSupportedException.printStackTrace();</span>
<span class="nc" id="L633">        }</span>
      }
<span class="nc" id="L635">      CallableStatement callableStatement = createNewCallableStatement(query,</span>
          procedureName,
          isFunction,
          databaseAndProcedure,
          database,
          arguments,
          resultSetType,
          resultSetConcurrency);
<span class="nc" id="L643">      callableStatementCache.put(new CallableStatementCacheKey(database, query), callableStatement);</span>
<span class="nc" id="L644">      return callableStatement;</span>
    }
<span class="nc" id="L646">    return createNewCallableStatement(query,</span>
        procedureName,
        isFunction,
        databaseAndProcedure,
        database,
        arguments,
        resultSetType,
        resultSetConcurrency);
  }

  /**
   * Creates a &lt;code&gt;CallableStatement&lt;/code&gt; object that will generate &lt;code&gt;ResultSet&lt;/code&gt;
   * objects with the given type and concurrency. This method is the same as the
   * &lt;code&gt;prepareCall&lt;/code&gt; method above, but it allows the default result set type, result set
   * concurrency type and holdability to be overridden.
   *
   * @param sql                  a &lt;code&gt;String&lt;/code&gt; object that is the SQL statement to be sent
   *                             to the database; may contain on or more '?' parameters
   * @param resultSetType        one of the following &lt;code&gt;ResultSet&lt;/code&gt; constants:
   *                             &lt;code&gt;ResultSet.TYPE_FORWARD_ONLY&lt;/code&gt;,
   *                             &lt;code&gt;ResultSet.TYPE_SCROLL_INSENSITIVE&lt;/code&gt;, or
   *                             &lt;code&gt;ResultSet.TYPE_SCROLL_SENSITIVE&lt;/code&gt;
   * @param resultSetConcurrency one of the following &lt;code&gt;ResultSet&lt;/code&gt; constants:
   *                             &lt;code&gt;ResultSet.CONCUR_READ_ONLY&lt;/code&gt; or
   *                             &lt;code&gt;ResultSet.CONCUR_UPDATABLE&lt;/code&gt;
   * @param resultSetHoldability one of the following &lt;code&gt;ResultSet&lt;/code&gt; constants:
   *                             &lt;code&gt;ResultSet.HOLD_CURSORS_OVER_COMMIT&lt;/code&gt; or
   *                             &lt;code&gt;ResultSet.CLOSE_CURSORS_AT_COMMIT&lt;/code&gt;
   * @return a new &lt;code&gt;CallableStatement&lt;/code&gt; object, containing the pre-compiled SQL statement,
   *     that will generate &lt;code&gt;ResultSet&lt;/code&gt; objects with the given type, concurrency, and
   *     holdability
   * @throws SQLException                    if a database access error occurs, this method is
   *                                         called on a closed connection or the given parameters
   *                                         are not
   *                                         &lt;code&gt;ResultSet&lt;/code&gt; constants indicating type,
   *                                         concurrency, and holdability
   * @see ResultSet
   */
  public CallableStatement prepareCall(final String sql,
      final int resultSetType,
      final int resultSetConcurrency,
      final int resultSetHoldability) throws SQLException {
<span class="nc" id="L688">    return prepareCall(sql);</span>
  }

  private CallableStatement createNewCallableStatement(String query, String procedureName,
      boolean isFunction,
      String databaseAndProcedure, String database, String arguments,
      int resultSetType, final int resultSetConcurrency) throws SQLException {
<span class="nc bnc" id="L695" title="All 2 branches missed.">    if (isFunction) {</span>
<span class="nc" id="L696">      return new MariaDbFunctionStatement(this,</span>
          database,
          databaseAndProcedure,
<span class="nc bnc" id="L699" title="All 2 branches missed.">          (arguments == null) ? &quot;()&quot; : arguments,</span>
          resultSetType,
          resultSetConcurrency);
    } else {
<span class="nc" id="L703">      return new MariaDbProcedureStatement(query,</span>
          this,
          procedureName,
          database,
          resultSetType,
          resultSetConcurrency);
    }
  }

  @Override
  public String nativeSQL(final String sql) throws SQLException {
<span class="nc" id="L714">    return Utils.nativeSql(sql, protocol.noBackslashEscapes());</span>
  }

  /**
   * returns true if statements on this connection are auto commited.
   *
   * @return true if auto commit is on.
   * @throws SQLException if there is an error
   */
  public boolean getAutoCommit() throws SQLException {
<span class="nc" id="L724">    return protocol.getAutocommit();</span>
  }

  /**
   * Sets whether this connection is auto commited.
   *
   * @param autoCommit if it should be auto commited.
   * @throws SQLException if something goes wrong talking to the server.
   */
  public void setAutoCommit(boolean autoCommit) throws SQLException {
<span class="nc bnc" id="L734" title="All 2 branches missed.">    if (autoCommit == getAutoCommit()) {</span>
<span class="nc" id="L735">      return;</span>
    }

<span class="nc" id="L738">    try (Statement stmt = createStatement()) {</span>
<span class="nc" id="L739">      stateFlag |= ConnectionState.STATE_AUTOCOMMIT;</span>
<span class="nc bnc" id="L740" title="All 2 branches missed.">      stmt.executeUpdate(&quot;set autocommit=&quot; + ((autoCommit) ? &quot;1&quot; : &quot;0&quot;));</span>
    }
<span class="nc" id="L742">  }</span>

  /**
   * Sends commit to the server.
   *
   * @throws SQLException if there is an error commiting.
   */
  public void commit() throws SQLException {
<span class="nc" id="L750">    lock.lock();</span>
    try {
<span class="nc bnc" id="L752" title="All 2 branches missed.">      if (protocol.inTransaction()) {</span>
<span class="nc" id="L753">        try (Statement st = createStatement()) {</span>
<span class="nc" id="L754">          st.execute(&quot;COMMIT&quot;);</span>
        }
      }
    } finally {
<span class="nc" id="L758">      lock.unlock();</span>
    }
<span class="nc" id="L760">  }</span>

  /**
   * Rolls back a transaction.
   *
   * @throws SQLException if there is an error rolling back.
   */
  public void rollback() throws SQLException {
<span class="nc" id="L768">    lock.lock();</span>
    try {
<span class="nc bnc" id="L770" title="All 2 branches missed.">      if (protocol.inTransaction()) {</span>
<span class="nc" id="L771">        try (Statement st = createStatement()) {</span>
<span class="nc" id="L772">          st.execute(&quot;ROLLBACK&quot;);</span>
        }
      }
    } finally {
<span class="nc" id="L776">      lock.unlock();</span>
    }
<span class="nc" id="L778">  }</span>

  /**
   * &lt;p&gt;Undoes all changes made after the given &lt;code&gt;Savepoint&lt;/code&gt; object was set.&lt;/p&gt;
   * &lt;p&gt;This method should be used only when auto-commit has been disabled.&lt;/p&gt;
   *
   * @param savepoint the &lt;code&gt;Savepoint&lt;/code&gt; object to roll back to
   * @throws SQLException                    if a database access error occurs, this method is
   *                                         called while participating in a distributed
   *                                         transaction, this method is called on a closed
   *                                         connection, the
   *                                         &lt;code&gt;Savepoint&lt;/code&gt; object is no longer valid, or
   *                                         this &lt;code&gt;Connection&lt;/code&gt; object is currently in
   *                                         auto-commit mode
   * @see Savepoint
   * @see #rollback
   */
  public void rollback(final Savepoint savepoint) throws SQLException {
<span class="nc" id="L796">    try (Statement st = createStatement()) {</span>
<span class="nc" id="L797">      st.execute(&quot;ROLLBACK TO SAVEPOINT &quot; + savepoint.toString());</span>
    }
<span class="nc" id="L799">  }</span>

  /**
   * close the connection.
   *
   * @throws SQLException if there is a problem talking to the server.
   */
  public void close() throws SQLException {
<span class="nc bnc" id="L807" title="All 2 branches missed.">    if (pooledConnection != null) {</span>
<span class="nc" id="L808">      rollback();</span>
<span class="nc" id="L809">      pooledConnection.fireConnectionClosed();</span>
<span class="nc" id="L810">      return;</span>
    }
<span class="nc" id="L812">    protocol.closeExplicit();</span>
<span class="nc" id="L813">  }</span>

  /**
   * checks if the connection is closed.
   *
   * @return true if the connection is closed
   */
  public boolean isClosed() {
<span class="nc" id="L821">    return protocol.isClosed();</span>
  }

  /**
   * returns the meta data about the database.
   *
   * @return meta data about the db.
   */
  public DatabaseMetaData getMetaData() {
<span class="nc" id="L830">    return new MariaDbDatabaseMetaData(this, protocol.getUrlParser());</span>
  }

  /**
   * Retrieves whether this &lt;code&gt;Connection&lt;/code&gt; object is in read-only mode.
   *
   * @return &lt;code&gt;true&lt;/code&gt; if this &lt;code&gt;Connection&lt;/code&gt; object is read-only;
   * &lt;code&gt;false&lt;/code&gt; otherwise
   * @throws SQLException SQLException if a database access error occurs or this method is called on
   *                      a closed connection
   */
  public boolean isReadOnly() throws SQLException {
<span class="nc" id="L842">    return protocol.getReadonly();</span>
  }

  /**
   * Sets whether this connection is read only.
   *
   * @param readOnly true if it should be read only.
   * @throws SQLException if there is a problem
   */
  public void setReadOnly(final boolean readOnly) throws SQLException {
    try {
<span class="nc" id="L853">      logger.debug(&quot;conn={}({}) - set read-only to value {} {}&quot;,</span>
<span class="nc" id="L854">          protocol.getServerThreadId(),</span>
<span class="nc bnc" id="L855" title="All 2 branches missed.">          protocol.isMasterConnection() ? &quot;M&quot; : &quot;S&quot;,</span>
<span class="nc" id="L856">          readOnly);</span>
<span class="nc" id="L857">      stateFlag |= ConnectionState.STATE_READ_ONLY;</span>
<span class="nc" id="L858">      protocol.setReadonly(readOnly);</span>
<span class="nc" id="L859">    } catch (SQLException e) {</span>
<span class="nc" id="L860">      throw ExceptionMapper.getException(e, this, null, false);</span>
<span class="nc" id="L861">    }</span>
<span class="nc" id="L862">  }</span>

  /**
   * &lt;p&gt;Retrieves this &lt;code&gt;Connection&lt;/code&gt; object's current catalog name.&lt;/p&gt;
   *
   * @return the current catalog name or &lt;code&gt;null&lt;/code&gt; if there is none
   * @throws SQLException if a database access error occurs or this method is called on a closed
   *                      connection
   * @see #setCatalog
   */
  public String getCatalog() throws SQLException {
<span class="nc" id="L873">    return protocol.getCatalog();</span>
  }

  /**
   * &lt;p&gt;Sets the given catalog name in order to select a subspace of this &lt;code&gt;Connection&lt;/code&gt;
   * object's database in which to work.&lt;/p&gt;
   * &lt;p&gt;If the driver does not support catalogs, it will silently ignore this request.&lt;/p&gt;
   * MariaDB treats catalogs and databases as equivalent
   *
   * @param catalog the name of a catalog (subspace in this &lt;code&gt;Connection&lt;/code&gt; object's
   *                database) in which to work
   * @throws SQLException if a database access error occurs or this method is called on a closed
   *                      connection
   * @see #getCatalog
   */
  public void setCatalog(final String catalog) throws SQLException {
<span class="nc bnc" id="L889" title="All 2 branches missed.">    if (catalog == null) {</span>
<span class="nc" id="L890">      throw new SQLException(&quot;The catalog name may not be null&quot;, &quot;XAE05&quot;);</span>
    }
    try {
<span class="nc" id="L893">      stateFlag |= ConnectionState.STATE_DATABASE;</span>
<span class="nc" id="L894">      protocol.setCatalog(catalog);</span>
<span class="nc" id="L895">    } catch (SQLException e) {</span>
<span class="nc" id="L896">      throw ExceptionMapper.getException(e, this, null, false);</span>
<span class="nc" id="L897">    }</span>
<span class="nc" id="L898">  }</span>

  public boolean isServerMariaDb() throws SQLException {
<span class="nc" id="L901">    return protocol.isServerMariaDb();</span>
  }

  public boolean versionGreaterOrEqual(int major, int minor, int patch) {
<span class="nc" id="L905">    return protocol.versionGreaterOrEqual(major, minor, patch);</span>
  }

  /**
   * Retrieves this &lt;code&gt;Connection&lt;/code&gt; object's current transaction isolation level.
   *
   * @return the current transaction isolation level, which will be one of the following constants:
   * &lt;code&gt;Connection.TRANSACTION_READ_UNCOMMITTED&lt;/code&gt;,
   * &lt;code&gt;Connection.TRANSACTION_READ_COMMITTED&lt;/code&gt;, &lt;code&gt;Connection.TRANSACTION_REPEATABLE_READ&lt;/code&gt;,
   * &lt;code&gt;Connection.TRANSACTION_SERIALIZABLE&lt;/code&gt;, or &lt;code&gt;Connection.TRANSACTION_NONE&lt;/code&gt;.
   * @throws SQLException if a database access error occurs or this method is called on a closed
   *                      connection
   * @see #setTransactionIsolation
   */
  public int getTransactionIsolation() throws SQLException {
<span class="nc" id="L920">    Statement stmt = createStatement();</span>
<span class="nc" id="L921">    String sql = &quot;SELECT @@tx_isolation&quot;;</span>

<span class="nc bnc" id="L923" title="All 2 branches missed.">    if (!protocol.isServerMariaDb()) {</span>
<span class="nc bnc" id="L924" title="All 4 branches missed.">      if ((protocol.getMajorServerVersion() &gt;= 8 &amp;&amp; protocol.versionGreaterOrEqual(8, 0, 3))</span>
<span class="nc bnc" id="L925" title="All 4 branches missed.">          || (protocol.getMajorServerVersion() &lt; 8 &amp;&amp; protocol.versionGreaterOrEqual(5, 7, 20))) {</span>
<span class="nc" id="L926">        sql = &quot;SELECT @@transaction_isolation&quot;;</span>
      }
    }

<span class="nc" id="L930">    ResultSet rs = stmt.executeQuery(sql);</span>
<span class="nc bnc" id="L931" title="All 2 branches missed.">    if (rs.next()) {</span>
<span class="nc" id="L932">      final String response = rs.getString(1);</span>
<span class="nc bnc" id="L933" title="All 5 branches missed.">      switch (response) {</span>
        case &quot;REPEATABLE-READ&quot;:
<span class="nc" id="L935">          return Connection.TRANSACTION_REPEATABLE_READ;</span>

        case &quot;READ-UNCOMMITTED&quot;:
<span class="nc" id="L938">          return Connection.TRANSACTION_READ_UNCOMMITTED;</span>

        case &quot;READ-COMMITTED&quot;:
<span class="nc" id="L941">          return Connection.TRANSACTION_READ_COMMITTED;</span>

        case &quot;SERIALIZABLE&quot;:
<span class="nc" id="L944">          return Connection.TRANSACTION_SERIALIZABLE;</span>

        default:
<span class="nc" id="L947">          throw ExceptionMapper.getSqlException(&quot;Could not get transaction isolation level: &quot;</span>
              + &quot;Invalid value \&quot;&quot; + response + &quot;\&quot;&quot;);
      }
    }
<span class="nc" id="L951">    throw ExceptionMapper.getSqlException(&quot;Could not get transaction isolation level&quot;);</span>
  }

  /**
   * &lt;p&gt;Attempts to change the transaction isolation level for this &lt;code&gt;Connection&lt;/code&gt; object
   * to the one given. The constants defined in the interface &lt;code&gt;Connection&lt;/code&gt; are the
   * possible transaction isolation levels.&lt;/p&gt;
   * &lt;p&gt;&lt;B&gt;Note:&lt;/B&gt; If this method is called during a transaction, the result is
   * implementation-defined.&lt;/p&gt;
   *
   * @param level one of the following &lt;code&gt;Connection&lt;/code&gt; constants:
   *              &lt;code&gt;Connection.TRANSACTION_READ_UNCOMMITTED&lt;/code&gt;,
   *              &lt;code&gt;Connection.TRANSACTION_READ_COMMITTED&lt;/code&gt;,
   *              &lt;code&gt;Connection.TRANSACTION_REPEATABLE_READ&lt;/code&gt;, or
   *              &lt;code&gt;Connection.TRANSACTION_SERIALIZABLE&lt;/code&gt;.
   *              (Note that &lt;code&gt;Connection.TRANSACTION_NONE&lt;/code&gt; cannot be used because it
   *              specifies that transactions are not supported.)
   * @throws SQLException if a database access error occurs, this method is called on a closed
   *                      connection or the given parameter is not one of the
   *                      &lt;code&gt;Connection&lt;/code&gt; constants
   * @see DatabaseMetaData#supportsTransactionIsolationLevel
   * @see #getTransactionIsolation
   */
  public void setTransactionIsolation(final int level) throws SQLException {
    try {
<span class="nc" id="L976">      stateFlag |= ConnectionState.STATE_TRANSACTION_ISOLATION;</span>
<span class="nc" id="L977">      protocol.setTransactionIsolation(level);</span>
<span class="nc" id="L978">    } catch (SQLException e) {</span>
<span class="nc" id="L979">      throw ExceptionMapper.getException(e, this, null, false);</span>
<span class="nc" id="L980">    }</span>
<span class="nc" id="L981">  }</span>

  /**
   * &lt;p&gt;Retrieves the first warning reported by calls on this &lt;code&gt;Connection&lt;/code&gt; object.  If
   * there is more than one warning, subsequent warnings will be chained to the first one and can be
   * retrieved by calling the method
   * &lt;code&gt;SQLWarning.getNextWarning&lt;/code&gt; on the warning that was retrieved previously.&lt;/p&gt;
   * &lt;p&gt;This method may not be called on a closed connection; doing so will cause an
   * &lt;code&gt;SQLException&lt;/code&gt; to be thrown.&lt;/p&gt;
   * &lt;p&gt;&lt;B&gt;Note:&lt;/B&gt; Subsequent warnings will be chained to this SQLWarning.&lt;/p&gt;
   *
   * @return the first &lt;code&gt;SQLWarning&lt;/code&gt; object or &lt;code&gt;null&lt;/code&gt; if there are none
   * @throws SQLException if a database access error occurs or this method is called on a closed
   *                      connection
   * @see SQLWarning
   */
  public SQLWarning getWarnings() throws SQLException {
<span class="nc bnc" id="L998" title="All 6 branches missed.">    if (warningsCleared || isClosed() || !protocol.hasWarnings()) {</span>
<span class="nc" id="L999">      return null;</span>
    }

<span class="nc" id="L1002">    SQLWarning last = null;</span>
<span class="nc" id="L1003">    SQLWarning first = null;</span>

<span class="nc" id="L1005">    try (Statement st = this.createStatement()) {</span>
<span class="nc" id="L1006">      try (ResultSet rs = st.executeQuery(&quot;show warnings&quot;)) {</span>
        // returned result set has 'level', 'code' and 'message' columns, in this order.
<span class="nc bnc" id="L1008" title="All 2 branches missed.">        while (rs.next()) {</span>
<span class="nc" id="L1009">          int code = rs.getInt(2);</span>
<span class="nc" id="L1010">          String message = rs.getString(3);</span>
<span class="nc" id="L1011">          SQLWarning warning = new SQLWarning(message, ExceptionMapper.mapCodeToSqlState(code),</span>
              code);
<span class="nc bnc" id="L1013" title="All 2 branches missed.">          if (first == null) {</span>
<span class="nc" id="L1014">            first = warning;</span>
<span class="nc" id="L1015">            last = warning;</span>
          } else {
<span class="nc" id="L1017">            last.setNextWarning(warning);</span>
<span class="nc" id="L1018">            last = warning;</span>
          }
<span class="nc" id="L1020">        }</span>
      }
    }
<span class="nc" id="L1023">    return first;</span>
  }

  /**
   * Clears all warnings reported for this &lt;code&gt;Connection&lt;/code&gt; object. After a call to this
   * method, the method &lt;code&gt;getWarnings&lt;/code&gt; returns
   * &lt;code&gt;null&lt;/code&gt; until a new warning is reported for this &lt;code&gt;Connection&lt;/code&gt; object.
   *
   * @throws SQLException SQLException if a database access error occurs or this method is called on
   *                      a closed connection
   */
  public void clearWarnings() throws SQLException {
<span class="nc bnc" id="L1035" title="All 2 branches missed.">    if (this.isClosed()) {</span>
<span class="nc" id="L1036">      throw ExceptionMapper</span>
<span class="nc" id="L1037">          .getSqlException(&quot;Connection.clearWarnings cannot be called on a closed connection&quot;);</span>
    }
<span class="nc" id="L1039">    warningsCleared = true;</span>
<span class="nc" id="L1040">  }</span>

  /**
   * Reenable warnings, when next statement is executed.
   */
  public void reenableWarnings() {
<span class="nc" id="L1046">    warningsCleared = false;</span>
<span class="nc" id="L1047">  }</span>

  /**
   * Retrieves the &lt;code&gt;Map&lt;/code&gt; object associated with this &lt;code&gt;Connection&lt;/code&gt; object.
   * Unless the application has added an entry, the type map returned will be empty.
   *
   * @return the &lt;code&gt;java.util.Map&lt;/code&gt; object associated with this &lt;code&gt;Connection&lt;/code&gt;
   *     object
   * @see #setTypeMap
   * @since 1.2
   */
  public Map&lt;String, Class&lt;?&gt;&gt; getTypeMap() {
<span class="nc" id="L1059">    return new HashMap&lt;&gt;();</span>
  }

  /**
   * Installs the given &lt;code&gt;TypeMap&lt;/code&gt; object as the type map for this &lt;code&gt;Connection&lt;/code&gt;
   * object. The type map will be used for the custom mapping of SQL structured types and distinct
   * types.
   *
   * @param map the &lt;code&gt;java.util.Map&lt;/code&gt; object to install as the replacement for this
   *            &lt;code&gt;Connection&lt;/code&gt; object's default type map
   * @throws SQLException                    if a database access error occurs, this method is
   *                                         called on a closed connection or the given parameter is
   *                                         not a
   *                                         &lt;code&gt;java.util.Map&lt;/code&gt; object
   * @see #getTypeMap
   */
  public void setTypeMap(final Map&lt;String, Class&lt;?&gt;&gt; map) throws SQLException {
<span class="nc" id="L1076">    throw ExceptionMapper.getFeatureNotSupportedException(&quot;Not yet supported&quot;);</span>
  }

  /**
   * Retrieves the current holdability of &lt;code&gt;ResultSet&lt;/code&gt; objects created using this
   * &lt;code&gt;Connection&lt;/code&gt; object.
   *
   * @return the holdability, one of &lt;code&gt;ResultSet.HOLD_CURSORS_OVER_COMMIT&lt;/code&gt; or
   * &lt;code&gt;ResultSet.CLOSE_CURSORS_AT_COMMIT&lt;/code&gt;
   * @see #setHoldability
   * @see DatabaseMetaData#getResultSetHoldability
   * @see ResultSet
   * @since 1.4
   */
  public int getHoldability() {
<span class="nc" id="L1091">    return ResultSet.HOLD_CURSORS_OVER_COMMIT;</span>
  }

  /**
   * Changes the default holdability of &lt;code&gt;ResultSet&lt;/code&gt; objects created using this
   * &lt;code&gt;Connection&lt;/code&gt; object to the given holdability. The default holdability of
   * &lt;code&gt;ResultSet&lt;/code&gt; objects can be be determined by invoking {@link
   * DatabaseMetaData#getResultSetHoldability}.
   *
   * @param holdability a &lt;code&gt;ResultSet&lt;/code&gt; holdability constant; one of
   *                    &lt;code&gt;ResultSet.HOLD_CURSORS_OVER_COMMIT&lt;/code&gt; or
   *                    &lt;code&gt;ResultSet.CLOSE_CURSORS_AT_COMMIT&lt;/code&gt;
   * @see #getHoldability
   * @see DatabaseMetaData#getResultSetHoldability
   * @see ResultSet
   */
  @Override
  public void setHoldability(final int holdability) {
    //not handled
<span class="nc" id="L1110">  }</span>

  /**
   * &lt;p&gt;Creates an unnamed savepoint in the current transaction and returns the new
   * &lt;code&gt;Savepoint&lt;/code&gt; object that
   * represents it.&lt;/p&gt;
   * &lt;p&gt;if setSavepoint is invoked outside of an active transaction, a transaction will be started
   * at this newly created savepoint.&lt;/p&gt;
   *
   * @return the new &lt;code&gt;Savepoint&lt;/code&gt; object
   * @throws SQLException                    if a database access error occurs, this method is
   *                                         called while participating in a distributed
   *                                         transaction, this method is called on a closed
   *                                         connection or this &lt;code&gt;Connection&lt;/code&gt; object is
   *                                         currently in auto-commit mode
   * @see Savepoint
   * @since 1.4
   */
  public Savepoint setSavepoint() throws SQLException {
<span class="nc" id="L1129">    return setSavepoint(&quot;unnamed&quot;);</span>
  }

  /**
   * &lt;p&gt;Creates a savepoint with the given name in the current transaction and returns the new
   * &lt;code&gt;Savepoint&lt;/code&gt;
   * object that represents it.&lt;/p&gt; if setSavepoint is invoked outside of an active transaction, a
   * transaction will be started at this newly created savepoint.
   *
   * @param name a &lt;code&gt;String&lt;/code&gt; containing the name of the savepoint
   * @return the new &lt;code&gt;Savepoint&lt;/code&gt; object
   * @throws SQLException                    if a database access error occurs, this method is
   *                                         called while participating in a distributed
   *                                         transaction, this method is called on a closed
   *                                         connection or this &lt;code&gt;Connection&lt;/code&gt; object is
   *                                         currently in auto-commit mode
   * @see Savepoint
   * @since 1.4
   */
  public Savepoint setSavepoint(final String name) throws SQLException {
<span class="nc" id="L1149">    Savepoint savepoint = new MariaDbSavepoint(name, savepointCount++);</span>
<span class="nc" id="L1150">    try (Statement st = createStatement()) {</span>
<span class="nc" id="L1151">      st.execute(&quot;SAVEPOINT &quot; + savepoint.toString());</span>
    }
<span class="nc" id="L1153">    return savepoint;</span>

  }


  /**
   * Removes the specified &lt;code&gt;Savepoint&lt;/code&gt;  and subsequent &lt;code&gt;Savepoint&lt;/code&gt; objects
   * from the current transaction. Any reference to the savepoint after it have been removed will
   * cause an &lt;code&gt;SQLException&lt;/code&gt; to be thrown.
   *
   * @param savepoint the &lt;code&gt;Savepoint&lt;/code&gt; object to be removed
   * @throws SQLException                    if a database access error occurs, this method is
   *                                         called on a closed connection or the given
   *                                         &lt;code&gt;Savepoint&lt;/code&gt; object is not a valid savepoint
   *                                         in the current transaction
   */
  public void releaseSavepoint(final Savepoint savepoint) throws SQLException {
<span class="nc" id="L1170">    try (Statement st = createStatement()) {</span>
<span class="nc" id="L1171">      st.execute(&quot;RELEASE SAVEPOINT &quot; + savepoint.toString());</span>
    }
<span class="nc" id="L1173">  }</span>

  /**
   * Constructs an object that implements the &lt;code&gt;Clob&lt;/code&gt; interface. The object returned
   * initially contains no data. The &lt;code&gt;setAsciiStream&lt;/code&gt;, &lt;code&gt;setCharacterStream&lt;/code&gt;
   * and &lt;code&gt;setString&lt;/code&gt; methods of the
   * &lt;code&gt;Clob&lt;/code&gt; interface may be used to add data to the &lt;code&gt;Clob&lt;/code&gt;.
   *
   * @return An object that implements the &lt;code&gt;Clob&lt;/code&gt; interface
   */
  public Clob createClob() {
<span class="nc" id="L1184">    return new MariaDbClob();</span>
  }

  /**
   * Constructs an object that implements the &lt;code&gt;Blob&lt;/code&gt; interface. The object returned
   * initially contains no data. The &lt;code&gt;setBinaryStream&lt;/code&gt; and &lt;code&gt;setBytes&lt;/code&gt; methods
   * of the &lt;code&gt;Blob&lt;/code&gt; interface may be used to add data to the &lt;code&gt;Blob&lt;/code&gt;.
   *
   * @return An object that implements the &lt;code&gt;Blob&lt;/code&gt; interface
   */
  public Blob createBlob() {
<span class="nc" id="L1195">    return new MariaDbBlob();</span>
  }

  /**
   * Constructs an object that implements the &lt;code&gt;NClob&lt;/code&gt; interface. The object returned
   * initially contains no data. The &lt;code&gt;setAsciiStream&lt;/code&gt;, &lt;code&gt;setCharacterStream&lt;/code&gt;
   * and &lt;code&gt;setString&lt;/code&gt; methods of the
   * &lt;code&gt;NClob&lt;/code&gt; interface may be used to add data to the &lt;code&gt;NClob&lt;/code&gt;.
   *
   * @return An object that implements the &lt;code&gt;NClob&lt;/code&gt; interface
   */
  public NClob createNClob() {
<span class="nc" id="L1207">    return new MariaDbClob();</span>
  }

  /**
   * Constructs an object that implements the &lt;code&gt;SQLXML&lt;/code&gt; interface. The object returned
   * initially contains no data. The &lt;code&gt;createXmlStreamWriter&lt;/code&gt; object and
   * &lt;code&gt;setString&lt;/code&gt; method of the &lt;code&gt;SQLXML&lt;/code&gt; interface may be used to add data to
   * the &lt;code&gt;SQLXML&lt;/code&gt; object.
   *
   * @return An object that implements the &lt;code&gt;SQLXML&lt;/code&gt; interface
   * @throws SQLException                    if an object that implements the &lt;code&gt;SQLXML&lt;/code&gt;
   *                                         interface can not be constructed, this method is called
   *                                         on a closed connection or a database access error
   *                                         occurs.
   */
  @Override
  public SQLXML createSQLXML() throws SQLException {
<span class="nc" id="L1224">    throw ExceptionMapper.getFeatureNotSupportedException(&quot;Not supported&quot;);</span>
  }

  /**
   * &lt;p&gt;Returns true if the connection has not been closed and is still valid. The driver shall
   * submit a query on the connection or use some other mechanism that positively verifies the
   * connection is still valid when this method is called.&lt;/p&gt;
   * &lt;p&gt;The query submitted by the driver to validate the connection shall be executed in the
   * context of the current transaction.&lt;/p&gt;
   *
   * @param timeout - The time in seconds to wait for the database operation used to validate the
   *                connection to complete. If the timeout period expires before the operation
   *                completes, this method returns false.  A value of 0 indicates a timeout is not
   *                applied to the database operation.
   * @return true if the connection is valid, false otherwise
   * @throws SQLException if the value supplied for &lt;code&gt;timeout&lt;/code&gt; is less then 0
   * @see DatabaseMetaData#getClientInfoProperties
   * @since 1.6
   */
  public boolean isValid(final int timeout) throws SQLException {
<span class="nc bnc" id="L1244" title="All 2 branches missed.">    if (timeout &lt; 0) {</span>
<span class="nc" id="L1245">      throw new SQLException(&quot;the value supplied for timeout is negative&quot;);</span>
    }
<span class="nc bnc" id="L1247" title="All 2 branches missed.">    if (isClosed()) {</span>
<span class="nc" id="L1248">      return false;</span>
    }

    try {
<span class="nc" id="L1252">      return protocol.isValid(timeout * 1000);</span>
<span class="nc" id="L1253">    } catch (SQLException e) {</span>
<span class="nc" id="L1254">      ExceptionMapper.checkConnectionException(e, this);</span>
<span class="nc" id="L1255">      return false;</span>
    }
  }

  private void checkClientClose(final String name) throws SQLClientInfoException {
<span class="nc bnc" id="L1260" title="All 2 branches missed.">    if (protocol.isExplicitClosed()) {</span>
<span class="nc" id="L1261">      Map&lt;String, ClientInfoStatus&gt; failures = new HashMap&lt;&gt;();</span>
<span class="nc" id="L1262">      failures.put(name, ClientInfoStatus.REASON_UNKNOWN);</span>
<span class="nc" id="L1263">      throw new SQLClientInfoException(&quot;setClientInfo() is called on closed connection&quot;, failures);</span>
    }
<span class="nc" id="L1265">  }</span>

  private void checkClientReconnect(final String name) throws SQLClientInfoException {
<span class="nc bnc" id="L1268" title="All 4 branches missed.">    if (protocol.isClosed() &amp;&amp; protocol.getProxy() != null) {</span>
<span class="nc" id="L1269">      lock.lock();</span>
      try {
<span class="nc" id="L1271">        protocol.getProxy().reconnect();</span>
<span class="nc" id="L1272">      } catch (SQLException sqle) {</span>
<span class="nc" id="L1273">        Map&lt;String, ClientInfoStatus&gt; failures = new HashMap&lt;&gt;();</span>
<span class="nc" id="L1274">        failures.put(name, ClientInfoStatus.REASON_UNKNOWN);</span>
<span class="nc" id="L1275">        throw new SQLClientInfoException(&quot;Connection closed&quot;, failures, sqle);</span>
      } finally {
<span class="nc" id="L1277">        lock.unlock();</span>
      }
    }
<span class="nc" id="L1280">  }</span>

  private void checkClientValidProperty(final String name) throws SQLClientInfoException {
<span class="nc bnc" id="L1283" title="All 4 branches missed.">    if (name == null || (!&quot;ApplicationName&quot;.equals(name)</span>
<span class="nc bnc" id="L1284" title="All 2 branches missed.">        &amp;&amp; !&quot;ClientUser&quot;.equals(name)</span>
<span class="nc bnc" id="L1285" title="All 2 branches missed.">        &amp;&amp; !&quot;ClientHostname&quot;.equals(name))) {</span>
<span class="nc" id="L1286">      Map&lt;String, ClientInfoStatus&gt; failures = new HashMap&lt;&gt;();</span>
<span class="nc" id="L1287">      failures.put(name, ClientInfoStatus.REASON_UNKNOWN_PROPERTY);</span>
<span class="nc" id="L1288">      throw new SQLClientInfoException(</span>
          &quot;setClientInfo() parameters can only be \&quot;ApplicationName\&quot;,\&quot;ClientUser\&quot; or \&quot;ClientHostname\&quot;, &quot;
              + &quot;but was : &quot; + name, failures);
    }
<span class="nc" id="L1292">  }</span>

  private String buildClientQuery(final String name, final String value) {
<span class="nc" id="L1295">    StringBuilder escapeQuery = new StringBuilder(&quot;SET @&quot;).append(name).append(&quot;=&quot;);</span>
<span class="nc bnc" id="L1296" title="All 2 branches missed.">    if (value == null) {</span>
<span class="nc" id="L1297">      escapeQuery.append(&quot;null&quot;);</span>
    } else {
<span class="nc" id="L1299">      escapeQuery.append(&quot;'&quot;);</span>
<span class="nc" id="L1300">      int charsOffset = 0;</span>
<span class="nc" id="L1301">      int charsLength = value.length();</span>
      char charValue;
<span class="nc bnc" id="L1303" title="All 2 branches missed.">      if (protocol.noBackslashEscapes()) {</span>
<span class="nc bnc" id="L1304" title="All 2 branches missed.">        while (charsOffset &lt; charsLength) {</span>
<span class="nc" id="L1305">          charValue = value.charAt(charsOffset);</span>
<span class="nc bnc" id="L1306" title="All 2 branches missed.">          if (charValue == '\'') {</span>
<span class="nc" id="L1307">            escapeQuery.append('\''); //add a single escape quote</span>
          }
<span class="nc" id="L1309">          escapeQuery.append(charValue);</span>
<span class="nc" id="L1310">          charsOffset++;</span>
        }
      } else {
<span class="nc bnc" id="L1313" title="All 2 branches missed.">        while (charsOffset &lt; charsLength) {</span>
<span class="nc" id="L1314">          charValue = value.charAt(charsOffset);</span>
<span class="nc bnc" id="L1315" title="All 8 branches missed.">          if (charValue == '\''</span>
              || charValue == '\\'
              || charValue == '&quot;'
              || charValue == 0) {
<span class="nc" id="L1319">            escapeQuery.append('\\'); //add escape slash</span>
          }
<span class="nc" id="L1321">          escapeQuery.append(charValue);</span>
<span class="nc" id="L1322">          charsOffset++;</span>
        }
      }
<span class="nc" id="L1325">      escapeQuery.append(&quot;'&quot;);</span>
    }
<span class="nc" id="L1327">    return escapeQuery.toString();</span>
  }

  /**
   * &lt;p&gt;Sets the value of the client info property specified by name to the value specified by
   * value.&lt;/p&gt;
   * &lt;p&gt;Applications may use the &lt;code&gt;DatabaseMetaData.getClientInfoProperties&lt;/code&gt; method to
   * determine the client info properties supported by the driver and the maximum length that may be
   * specified for each property.&lt;/p&gt;
   * &lt;p&gt;The driver stores the value specified in a suitable location in the database.  For example
   * in a special register, session parameter, or system table column.  For efficiency the driver
   * may defer setting the value in the database until the next time a statement is executed or
   * prepared. Other than storing the client information in the appropriate place in the database,
   * these methods shall not alter the behavior of the connection in anyway.  The values supplied to
   * these methods are used for accounting, diagnostics and debugging purposes only.&lt;/p&gt;
   * &lt;p&gt;The driver shall generate a warning if the client info name specified is not recognized by
   * the driver.&lt;/p&gt;
   * &lt;p&gt;If the value specified to this method is greater than the maximum length for the property
   * the driver may either truncate the value and generate a warning or generate a
   * &lt;code&gt;SQLClientInfoException&lt;/code&gt;.  If the driver generates a &lt;code&gt;SQLClientInfoException&lt;/code&gt;,
   * the value specified was not set on the connection.&lt;/p&gt;
   * &lt;p&gt;The following are standard client info properties.  Drivers are not required to support
   * these properties however if the driver supports a client info property that can be described by
   * one of the standard properties, the standard property name should be used.&lt;/p&gt;
   * &lt;ul&gt; &lt;li&gt;ApplicationName  -       The name of the application currently utilizing the
   * connection&lt;/li&gt; &lt;li&gt;ClientUser -       The name of the user that the application using the
   * connection is performing work for.  This may not be the same as the user name that was used in
   * establishing the connection.&lt;/li&gt;
   * &lt;li&gt;ClientHostname   -       The hostname of the computer the application using the connection
   * is running on.&lt;/li&gt; &lt;/ul&gt;
   *
   * @param name  The name of the client info property to set
   * @param value The value to set the client info property to.  If the value is null, the current
   *              value of the specified property is cleared.
   * @throws SQLClientInfoException if the database server returns an error while setting the client
   *                                info value on the database server or this method is called on a
   *                                closed connection
   * @since 1.6
   */
  public void setClientInfo(final String name, final String value) throws SQLClientInfoException {
<span class="nc" id="L1367">    checkClientClose(name);</span>
<span class="nc" id="L1368">    checkClientReconnect(name);</span>
<span class="nc" id="L1369">    checkClientValidProperty(name);</span>

    try {
<span class="nc" id="L1372">      Statement statement = createStatement();</span>
<span class="nc" id="L1373">      statement.execute(buildClientQuery(name, value));</span>
<span class="nc" id="L1374">    } catch (SQLException sqle) {</span>
<span class="nc" id="L1375">      Map&lt;String, ClientInfoStatus&gt; failures = new HashMap&lt;&gt;();</span>
<span class="nc" id="L1376">      failures.put(name, ClientInfoStatus.REASON_UNKNOWN);</span>
<span class="nc" id="L1377">      throw new SQLClientInfoException(&quot;unexpected error during setClientInfo&quot;, failures, sqle);</span>
<span class="nc" id="L1378">    }</span>
<span class="nc" id="L1379">  }</span>

  /**
   * &lt;p&gt;Sets the value of the connection's client info properties.  The &lt;code&gt;Properties&lt;/code&gt;
   * object contains the names and values of the client info properties to be set.  The set of
   * client info properties contained in the properties list replaces the current set of client info
   * properties on the connection.  If a property that is currently set on the connection is not
   * present in the properties list, that property is cleared. Specifying an empty properties list
   * will clear all of the properties on the connection.  See
   * &lt;code&gt;setClientInfo (String, String)&lt;/code&gt; for more information.&lt;/p&gt;
   *
   * &lt;p&gt;If an error occurs in setting any of the client info properties, a
   * &lt;code&gt;SQLClientInfoException&lt;/code&gt; is
   * thrown. The &lt;code&gt;SQLClientInfoException&lt;/code&gt; contains information indicating which client
   * info properties were not set. The state of the client information is unknown because some
   * databases do not allow multiple client info properties to be set atomically.  For those
   * databases, one or more properties may have been set before the error occurred.&lt;/p&gt;
   *
   * @param properties the list of client info properties to set
   * @throws SQLClientInfoException if the database server returns an error while setting the
   *                                clientInfo values on the database server or this method is
   *                                called on a closed connection
   * @see Connection#setClientInfo(String, String) setClientInfo(String, String)
   * @since 1.6
   */
  public void setClientInfo(final Properties properties) throws SQLClientInfoException {
<span class="nc" id="L1405">    Map&lt;String, ClientInfoStatus&gt; propertiesExceptions = new HashMap&lt;&gt;();</span>
<span class="nc bnc" id="L1406" title="All 2 branches missed.">    for (String name : new String[]{&quot;ApplicationName&quot;, &quot;ClientUser&quot;, &quot;ClientHostname&quot;}) {</span>
      try {
<span class="nc" id="L1408">        setClientInfo(name, properties.getProperty(name));</span>
<span class="nc" id="L1409">      } catch (SQLClientInfoException e) {</span>
<span class="nc" id="L1410">        propertiesExceptions.putAll(e.getFailedProperties());</span>
<span class="nc" id="L1411">      }</span>
    }

<span class="nc bnc" id="L1414" title="All 2 branches missed.">    if (!propertiesExceptions.isEmpty()) {</span>
<span class="nc" id="L1415">      String errorMsg =</span>
          &quot;setClientInfo errors : the following properties where not set : &quot; + propertiesExceptions
<span class="nc" id="L1417">              .keySet();</span>
<span class="nc" id="L1418">      throw new SQLClientInfoException(errorMsg, propertiesExceptions);</span>
    }
<span class="nc" id="L1420">  }</span>

  /**
   * Returns a list containing the name and current value of each client info property supported by
   * the driver.  The value of a client info property may be null if the property has not been set
   * and does not have a default value.
   *
   * @return A &lt;code&gt;Properties&lt;/code&gt; object that contains the name and current value of each of
   *     the client info properties supported by the driver.
   * @throws SQLException if the database server returns an error when fetching the client info
   *                      values from the database or this method is called on a closed connection
   */
  public Properties getClientInfo() throws SQLException {
<span class="nc" id="L1433">    checkConnection();</span>
<span class="nc" id="L1434">    Properties properties = new Properties();</span>
<span class="nc" id="L1435">    try (Statement statement = createStatement()) {</span>
<span class="nc" id="L1436">      try (ResultSet rs = statement</span>
<span class="nc" id="L1437">          .executeQuery(&quot;SELECT @ApplicationName, @ClientUser, @ClientHostname&quot;)) {</span>
<span class="nc bnc" id="L1438" title="All 2 branches missed.">        if (rs.next()) {</span>
<span class="nc bnc" id="L1439" title="All 2 branches missed.">          if (rs.getString(1) != null) {</span>
<span class="nc" id="L1440">            properties.setProperty(&quot;ApplicationName&quot;, rs.getString(1));</span>
          }
<span class="nc bnc" id="L1442" title="All 2 branches missed.">          if (rs.getString(2) != null) {</span>
<span class="nc" id="L1443">            properties.setProperty(&quot;ClientUser&quot;, rs.getString(2));</span>
          }
<span class="nc bnc" id="L1445" title="All 2 branches missed.">          if (rs.getString(3) != null) {</span>
<span class="nc" id="L1446">            properties.setProperty(&quot;ClientHostname&quot;, rs.getString(3));</span>
          }
<span class="nc" id="L1448">          return properties;</span>
        }
<span class="nc bnc" id="L1450" title="All 2 branches missed.">      }</span>
<span class="nc bnc" id="L1451" title="All 2 branches missed.">    }</span>
<span class="nc" id="L1452">    properties.setProperty(&quot;ApplicationName&quot;, null);</span>
<span class="nc" id="L1453">    properties.setProperty(&quot;ClientUser&quot;, null);</span>
<span class="nc" id="L1454">    properties.setProperty(&quot;ClientHostname&quot;, null);</span>
<span class="nc" id="L1455">    return properties;</span>
  }

  /**
   * Returns the value of the client info property specified by name.  This method may return null
   * if the specified client info property has not been set and does not have a default value.  This
   * method will also return null if the specified client info property name is not supported by the
   * driver. Applications may use the &lt;code&gt;DatabaseMetaData.getClientInfoProperties&lt;/code&gt; method
   * to determine the client info properties supported by the driver.
   *
   * @param name The name of the client info property to retrieve
   * @return The value of the client info property specified
   * @throws SQLException if the database server returns an error when fetching the client info
   *                      value from the database or this method is called on a closed connection
   * @see DatabaseMetaData#getClientInfoProperties
   * @since 1.6
   */
  public String getClientInfo(final String name) throws SQLException {
<span class="nc" id="L1473">    checkConnection();</span>
<span class="nc bnc" id="L1474" title="All 4 branches missed.">    if (!&quot;ApplicationName&quot;.equals(name) &amp;&amp; !&quot;ClientUser&quot;.equals(name) &amp;&amp; !&quot;ClientHostname&quot;</span>
<span class="nc bnc" id="L1475" title="All 2 branches missed.">        .equals(name)) {</span>
<span class="nc" id="L1476">      throw new SQLException(</span>
          &quot;name must be \&quot;ApplicationName\&quot;, \&quot;ClientUser\&quot; or \&quot;ClientHostname\&quot;, but was \&quot;&quot;
              + name + &quot;\&quot;&quot;);
    }
<span class="nc" id="L1480">    try (Statement statement = createStatement()) {</span>
<span class="nc" id="L1481">      try (ResultSet rs = statement.executeQuery(&quot;SELECT @&quot; + name)) {</span>
<span class="nc bnc" id="L1482" title="All 2 branches missed.">        if (rs.next()) {</span>
<span class="nc" id="L1483">          return rs.getString(1);</span>
        }
<span class="nc bnc" id="L1485" title="All 2 branches missed.">      }</span>
<span class="nc bnc" id="L1486" title="All 2 branches missed.">    }</span>
<span class="nc" id="L1487">    return null;</span>
  }

  /**
   * Factory method for creating Array objects.
   * &lt;b&gt;Note: &lt;/b&gt;When &lt;code&gt;createArrayOf&lt;/code&gt; is used to create an array object that maps to a
   * primitive data type, then it is implementation-defined whether the &lt;code&gt;Array&lt;/code&gt; object is
   * an array of that primitive data type or an array of &lt;code&gt;Object&lt;/code&gt;.
   * &lt;b&gt;Note: &lt;/b&gt;The JDBC driver is responsible for mapping the elements &lt;code&gt;Object&lt;/code&gt; array
   * to the default JDBC SQL type defined in java.sql.Types for the given class of
   * &lt;code&gt;Object&lt;/code&gt;. The default mapping is specified in Appendix B of the JDBC specification.
   * If the resulting JDBC type is not the appropriate type for the given typeName then it is
   * implementation defined whether an &lt;code&gt;SQLException&lt;/code&gt; is thrown or the driver supports
   * the resulting conversion.
   *
   * @param typeName the SQL name of the type the elements of the array map to. The typeName is a
   *                 database-specific name which may be the name of a built-in type, a user-defined
   *                 type or a standard  SQL type supported by this database. This is the value
   *                 returned by
   *                 &lt;code&gt;Array.getBaseTypeName&lt;/code&gt;
   * @param elements the elements that populate the returned object
   * @return an Array object whose elements map to the specified SQL type
   * @throws SQLException                    if a database error occurs, the JDBC type is not
   *                                         appropriate for the typeName and the conversion is not
   *                                         supported, the typeName is null or this method is
   *                                         called on a closed connection
   */
  public Array createArrayOf(final String typeName, final Object[] elements) throws SQLException {
<span class="nc" id="L1515">    throw ExceptionMapper.getFeatureNotSupportedException(&quot;Not yet supported&quot;);</span>
  }

  /**
   * Factory method for creating Struct objects.
   *
   * @param typeName   the SQL type name of the SQL structured type that this &lt;code&gt;Struct&lt;/code&gt;
   *                   object maps to. The typeName is the name of  a user-defined type that has
   *                   been defined for this database. It is the value returned by
   *                   &lt;code&gt;Struct.getSQLTypeName&lt;/code&gt;.
   * @param attributes the attributes that populate the returned object
   * @return a Struct object that maps to the given SQL type and is populated with the given
   *      attributes
   * @throws SQLException                    if a database error occurs, the typeName is null or
   *                                         this method is called on a closed connection
   */
  public Struct createStruct(final String typeName, final Object[] attributes) throws SQLException {
<span class="nc" id="L1532">    throw ExceptionMapper.getFeatureNotSupportedException(&quot;Not yet supported&quot;);</span>
  }

  /**
   * Returns an object that implements the given interface to allow access to non-standard methods,
   * or standard methods not exposed by the proxy. If the receiver implements the interface then the
   * result is the receiver or a proxy for the receiver. If the receiver is a wrapper and the
   * wrapped object implements the interface then the result is the wrapped object or a proxy for
   * the wrapped object. Otherwise return the the result of calling &lt;code&gt;unwrap&lt;/code&gt; recursively
   * on the wrapped object or a proxy for that result. If the receiver is not a wrapper and does not
   * implement the interface, then an &lt;code&gt;SQLException&lt;/code&gt; is thrown.
   *
   * @param iface A Class defining an interface that the result must implement.
   * @return an object that implements the interface. May be a proxy for the actual implementing
   *     object.
   * @throws SQLException If no object found that implements the interface
   * @since 1.6
   */
  public &lt;T&gt; T unwrap(final Class&lt;T&gt; iface) throws SQLException {
    try {
<span class="nc bnc" id="L1552" title="All 2 branches missed.">      if (isWrapperFor(iface)) {</span>
<span class="nc" id="L1553">        return iface.cast(this);</span>
      } else {
<span class="nc" id="L1555">        throw new SQLException(&quot;The receiver is not a wrapper for &quot; + iface.getName());</span>
      }
<span class="nc" id="L1557">    } catch (Exception e) {</span>
<span class="nc" id="L1558">      throw new SQLException(&quot;The receiver is not a wrapper and does not implement the interface&quot;);</span>
    }
  }

  /**
   * Returns true if this either implements the interface argument or is directly or indirectly a
   * wrapper for an object that does. Returns false otherwise. If this implements the interface then
   * return true, else if this is a wrapper then return the result of recursively calling
   * &lt;code&gt;isWrapperFor&lt;/code&gt; on the wrapped object. If this does not implement the interface and
   * is not a wrapper, return false. This method should be implemented as a low-cost operation
   * compared to &lt;code&gt;unwrap&lt;/code&gt; so that callers can use this method to avoid expensive
   * &lt;code&gt;unwrap&lt;/code&gt; calls that may fail. If this method returns true then calling
   * &lt;code&gt;unwrap&lt;/code&gt; with the same argument should succeed.
   *
   * @param iface a Class defining an interface.
   * @return true if this implements the interface or directly or indirectly wraps an object that
   *     does.
   * @since 1.6
   */
  public boolean isWrapperFor(final Class&lt;?&gt; iface) {
<span class="nc" id="L1578">    return iface.isInstance(this);</span>
  }

  /**
   * returns the username for the connection.
   *
   * @return the username.
   */
  @Deprecated
  public String getUsername() {
<span class="nc" id="L1588">    return protocol.getUsername();</span>
  }

  /**
   * returns the hostname for the connection.
   *
   * @return the hostname.
   */
  @Deprecated
  public String getHostname() {
<span class="nc" id="L1598">    return protocol.getHost();</span>
  }

  /**
   * returns the port for the connection.
   *
   * @return the port
   */
  @Deprecated
  public int getPort() {
<span class="nc" id="L1608">    return protocol.getPort();</span>
  }

  protected boolean getPinGlobalTxToPhysicalConnection() {
<span class="nc" id="L1612">    return protocol.getPinGlobalTxToPhysicalConnection();</span>
  }

  /**
   * If failover is not activated, will close connection when a connection error occur.
   */
  public void setHostFailed() {
<span class="nc bnc" id="L1619" title="All 2 branches missed.">    if (protocol.getProxy() == null) {</span>
<span class="nc" id="L1620">      protocol.setHostFailedWithoutProxy();</span>
    }
<span class="nc" id="L1622">  }</span>

  /**
   * Are table case sensitive or not . Default Value: 0 (Unix), 1 (Windows), 2 (Mac OS X). If set to
   * 0 (the default on Unix-based systems), table names and aliases and database names are compared
   * in a case-sensitive manner. If set to 1 (the default on Windows), names are stored in lowercase
   * and not compared in a case-sensitive manner. If set to 2 (the default on Mac OS X), names are
   * stored as declared, but compared in lowercase.
   *
   * @return int value.
   * @throws SQLException if a connection error occur
   */
  public int getLowercaseTableNames() throws SQLException {
<span class="nc bnc" id="L1635" title="All 2 branches missed.">    if (lowercaseTableNames == -1) {</span>
<span class="nc" id="L1636">      try (Statement st = createStatement()) {</span>
<span class="nc" id="L1637">        try (ResultSet rs = st.executeQuery(&quot;select @@lower_case_table_names&quot;)) {</span>
<span class="nc" id="L1638">          rs.next();</span>
<span class="nc" id="L1639">          lowercaseTableNames = rs.getInt(1);</span>
        }
      }
    }
<span class="nc" id="L1643">    return lowercaseTableNames;</span>
  }

  /**
   * Abort connection.
   *
   * @param executor executor
   * @throws SQLException if security manager doesn't permit it.
   */
  public void abort(Executor executor) throws SQLException {
<span class="nc bnc" id="L1653" title="All 2 branches missed.">    if (this.isClosed()) {</span>
<span class="nc" id="L1654">      return;</span>
    }

<span class="nc" id="L1657">    SQLPermission sqlPermission = new SQLPermission(&quot;callAbort&quot;);</span>
<span class="nc" id="L1658">    SecurityManager securityManager = System.getSecurityManager();</span>
<span class="nc bnc" id="L1659" title="All 2 branches missed.">    if (securityManager != null) {</span>
<span class="nc" id="L1660">      securityManager.checkPermission(sqlPermission);</span>
    }
<span class="nc bnc" id="L1662" title="All 2 branches missed.">    if (executor == null) {</span>
<span class="nc" id="L1663">      throw ExceptionMapper.getSqlException(&quot;Cannot abort the connection: null executor passed&quot;);</span>
    }

<span class="nc" id="L1666">    executor.execute(protocol::abort);</span>
<span class="nc" id="L1667">  }</span>

  /**
   * Get network timeout.
   *
   * @return timeout
   * @throws SQLException if database socket error occur
   */
  public int getNetworkTimeout() throws SQLException {
    try {
<span class="nc" id="L1677">      return this.protocol.getTimeout();</span>
<span class="nc" id="L1678">    } catch (SocketException se) {</span>
<span class="nc" id="L1679">      throw ExceptionMapper.getSqlException(&quot;Cannot retrieve the network timeout&quot;, se);</span>
    }
  }

  public String getSchema() {
    // We support only catalog
<span class="nc" id="L1685">    return null;</span>
  }

  public void setSchema(String arg0) {
    // We support only catalog, and JDBC indicate &quot;If the driver does not support schemas, it will silently ignore this request.&quot;
<span class="nc" id="L1690">  }</span>


  /**
   * Change network timeout.
   *
   * @param executor     executor (can be null)
   * @param milliseconds network timeout in milliseconds.
   * @throws SQLException if security manager doesn't permit it.
   */
  public void setNetworkTimeout(Executor executor, final int milliseconds) throws SQLException {
<span class="nc bnc" id="L1701" title="All 2 branches missed.">    if (this.isClosed()) {</span>
<span class="nc" id="L1702">      throw ExceptionMapper</span>
<span class="nc" id="L1703">          .getSqlException(&quot;Connection.setNetworkTimeout cannot be called on a closed connection&quot;);</span>
    }
<span class="nc bnc" id="L1705" title="All 2 branches missed.">    if (milliseconds &lt; 0) {</span>
<span class="nc" id="L1706">      throw ExceptionMapper</span>
<span class="nc" id="L1707">          .getSqlException(&quot;Connection.setNetworkTimeout cannot be called with a negative timeout&quot;);</span>
    }
<span class="nc" id="L1709">    SQLPermission sqlPermission = new SQLPermission(&quot;setNetworkTimeout&quot;);</span>
<span class="nc" id="L1710">    SecurityManager securityManager = System.getSecurityManager();</span>
<span class="nc bnc" id="L1711" title="All 2 branches missed.">    if (securityManager != null) {</span>
<span class="nc" id="L1712">      securityManager.checkPermission(sqlPermission);</span>
    }
    try {
<span class="nc" id="L1715">      stateFlag |= ConnectionState.STATE_NETWORK_TIMEOUT;</span>
<span class="nc" id="L1716">      protocol.setTimeout(milliseconds);</span>
<span class="nc" id="L1717">    } catch (SocketException se) {</span>
<span class="nc" id="L1718">      throw ExceptionMapper.getSqlException(&quot;Cannot set the network timeout&quot;, se);</span>
<span class="nc" id="L1719">    }</span>
<span class="nc" id="L1720">  }</span>

  public long getServerThreadId() {
<span class="nc" id="L1723">    return protocol.getServerThreadId();</span>
  }

  public boolean canUseServerTimeout() {
<span class="nc" id="L1727">    return canUseServerTimeout;</span>
  }


  public void setDefaultTransactionIsolation(int defaultTransactionIsolation) {
<span class="nc" id="L1732">    this.defaultTransactionIsolation = defaultTransactionIsolation;</span>
<span class="nc" id="L1733">  }</span>

  /**
   * Reset connection set has it was after creating a &quot;fresh&quot; new connection.
   * defaultTransactionIsolation must have been initialized.
   *
   * &lt;p&gt;BUT : - session variable state are reset only if option useResetConnection is set and - if
   * using the option &quot;useServerPrepStmts&quot;, PREPARE statement are still prepared&lt;/p&gt;
   *
   * @throws SQLException if resetting operation failed
   */
  public void reset() throws SQLException {
<span class="nc bnc" id="L1745" title="All 2 branches missed.">    boolean useComReset = options.useResetConnection</span>
<span class="nc bnc" id="L1746" title="All 4 branches missed.">        &amp;&amp; ((protocol.isServerMariaDb() &amp;&amp; protocol.versionGreaterOrEqual(10, 2, 4))</span>
<span class="nc bnc" id="L1747" title="All 4 branches missed.">        || (!protocol.isServerMariaDb() &amp;&amp; protocol.versionGreaterOrEqual(5, 7, 3)));</span>

<span class="nc bnc" id="L1749" title="All 2 branches missed.">    if (useComReset) {</span>
<span class="nc" id="L1750">      protocol.reset();</span>
    }

<span class="nc bnc" id="L1753" title="All 2 branches missed.">    if (stateFlag != 0) {</span>

      try {

<span class="nc bnc" id="L1757" title="All 2 branches missed.">        if ((stateFlag &amp; ConnectionState.STATE_NETWORK_TIMEOUT) != 0) {</span>
<span class="nc" id="L1758">          setNetworkTimeout(null, options.socketTimeout);</span>
        }

<span class="nc bnc" id="L1761" title="All 2 branches missed.">        if ((stateFlag &amp; ConnectionState.STATE_AUTOCOMMIT) != 0) {</span>
<span class="nc" id="L1762">          setAutoCommit(options.autocommit);</span>
        }

<span class="nc bnc" id="L1765" title="All 2 branches missed.">        if ((stateFlag &amp; ConnectionState.STATE_DATABASE) != 0) {</span>
<span class="nc" id="L1766">          protocol.resetDatabase();</span>
        }

<span class="nc bnc" id="L1769" title="All 2 branches missed.">        if ((stateFlag &amp; ConnectionState.STATE_READ_ONLY) != 0) {</span>
<span class="nc" id="L1770">          setReadOnly(false); //default to master connection</span>
        }

        //COM_RESET_CONNECTION reset transaction isolation
<span class="nc bnc" id="L1774" title="All 4 branches missed.">        if (!useComReset &amp;&amp; (stateFlag &amp; ConnectionState.STATE_TRANSACTION_ISOLATION) != 0) {</span>
<span class="nc" id="L1775">          setTransactionIsolation(defaultTransactionIsolation);</span>
        }

<span class="nc" id="L1778">        stateFlag = 0;</span>

<span class="nc" id="L1780">      } catch (SQLException sqle) {</span>
<span class="nc" id="L1781">        throw ExceptionMapper.getSqlException(&quot;error resetting connection&quot;);</span>
<span class="nc" id="L1782">      }</span>
    }

<span class="nc" id="L1785">    warningsCleared = true;</span>
<span class="nc" id="L1786">  }</span>

  public boolean includeDeadLockInfo() {
<span class="nc" id="L1789">    return options.includeInnodbStatusInDeadlockExceptions;</span>
  }

  public boolean includeThreadsTraces() {
<span class="nc" id="L1793">    return options.includeInnodbStatusInDeadlockExceptions;</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>